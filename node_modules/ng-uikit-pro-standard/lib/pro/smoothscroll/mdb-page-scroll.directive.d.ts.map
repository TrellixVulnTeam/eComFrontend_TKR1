{"version":3,"file":"mdb-page-scroll.directive.d.ts","sources":["../../../../../projects/ng-uikit-pro-standard/src/lib/pro/smoothscroll/mdb-page-scroll.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EAIL,YAAY,EACZ,SAAS,EAGT,SAAS,EAEV,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,MAAM,EAA6D,MAAM,iBAAiB,CAAC;AAKpG,OAAO,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;AAG9D,OAAO,EAAE,WAAW,EAAE,MAAM,0BAA0B,CAAC;;AAEvD,qBAGa,mBAAoB,YAAW,SAAS,EAAE,SAAS;AAChE,IAiBI,OAAO,CAAC,iBAAiB;AAAE,IACf,OAAO,CAAC,MAAM;AAAE,IAlBd,UAAU,EAAE,GAAG,CAAC;AAClC,IAAkB,IAAI,EAAE,MAAM,CAAC;AAC/B,IAAkB,oBAAoB,EAAE,OAAO,GAAG,GAAG,CAAQ;AAC7D,IAAkB,gBAAgB,EAAE,MAAM,GAAG,GAAG,CAAQ;AACxD,IAAkB,kBAAkB,EAAE,MAAM,GAAG,GAAG,CAAQ;AAC1D,IAAkB,eAAe,EAAE,MAAM,GAAG,GAAG,CAAQ;AACvD,IAAkB,gBAAgB,EAAE,WAAW,GAAG,GAAG,CAAQ;AAC7D,IAAkB,uBAAuB,EAAE,OAAO,CAAC;AACnD,IAAkB,oBAAoB,UAAS;AAC/C,IAAkB,UAAU,EAAE,MAAM,GAAG,GAAG,CAAQ;AAClD,IACY,gBAAgB,EAAE,YAAY,CAAC,OAAO,CAAC,CAA+B;AAClF,IACE,OAAO,CAAC,kBAAkB,CAA2B;AACvD,IAAE,OAAO,CAAC,QAAQ,CAAW;AAC7B,gBAEY,iBAAiB,EAAE,iBAAiB,EACxB,MAAM,EAAE,MAAM,EAChB,QAAQ,EAAE,GAAG;AACjC,IAIA,WAAW,IAAI,IAAI;AAAE,IAKrB,WAAW,IAAI,IAAI;AAAE,IAOrB,OAAO,CAAC,0BAA0B;AAAE,IAmBpC,OAAO,CAAC,eAAe;AAAE,IAczB,OAAO,CAAC,MAAM;AAAE,IAOT,WAAW,IAAI,OAAO;;;AAAE,CA+BhC;AACD","sourcesContent":["import {\n  Directive,\n  Input,\n  Output,\n  EventEmitter,\n  OnDestroy,\n  Inject,\n  Optional,\n  OnChanges,\n  HostListener,\n} from '@angular/core';\nimport { Router, NavigationEnd, NavigationError, NavigationCancel, UrlTree } from '@angular/router';\nimport { DOCUMENT } from '@angular/common';\n\nimport { Subscription } from 'rxjs';\n\nimport { PageScrollService } from './mdb-page-scroll.service';\nimport { PageScrollInstance } from './mdb-page-scroll.instance';\nimport { PageScrollUtilService as Util } from './mdb-page-scroll-util.service';\nimport { EasingLogic } from './mdb-page-scroll.config';\n\n@Directive({\n  selector: '[mdbPageScroll]',\n})\nexport class PageScrollDirective implements OnChanges, OnDestroy {\n  @Input() public routerLink: any;\n  @Input() public href: string;\n  @Input() public pageScrollHorizontal: boolean | any = null;\n  @Input() public pageScrollOffset: number | any = null;\n  @Input() public pageScrollDuration: number | any = null;\n  @Input() public pageScrollSpeed: number | any = null;\n  @Input() public pageScrollEasing: EasingLogic | any = null;\n  @Input() public pageScrollInterruptible: boolean;\n  @Input() public pageScrollAdjustHash = false;\n  @Input() public pageScroll: string | any = null;\n\n  @Output() pageScrollFinish: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  private pageScrollInstance: PageScrollInstance | any;\n  private document: Document;\n\n  constructor(\n    private pageScrollService: PageScrollService,\n    @Optional() private router: Router,\n    @Inject(DOCUMENT) document: any\n  ) {\n    this.document = <Document>document;\n  }\n\n  ngOnChanges(): void {\n    // Some inputs changed, reset the pageScrollInstance\n    this.pageScrollInstance = undefined;\n  }\n\n  ngOnDestroy(): void {\n    if (this.pageScrollInstance) {\n      this.pageScrollService.stop(this.pageScrollInstance);\n    }\n    return undefined;\n  }\n\n  private generatePageScrollInstance(): PageScrollInstance | any {\n    if (Util.isUndefinedOrNull(this.pageScrollInstance)) {\n      this.pageScrollInstance = PageScrollInstance.newInstance({\n        document: this.document,\n        scrollTarget: this.href,\n        scrollingViews: null,\n        namespace: this.pageScroll,\n        verticalScrolling: !this.pageScrollHorizontal,\n        pageScrollOffset: this.pageScrollOffset,\n        pageScrollInterruptible: this.pageScrollInterruptible,\n        pageScrollEasingLogic: this.pageScrollEasing,\n        pageScrollDuration: this.pageScrollDuration,\n        pageScrollSpeed: this.pageScrollSpeed,\n        pageScrollFinishListener: this.pageScrollFinish,\n      });\n    }\n    return this.pageScrollInstance;\n  }\n\n  private pushRouterState() {\n    if (\n      this.pageScrollAdjustHash &&\n      typeof this.pageScrollInstance.scrollTarget === 'string' &&\n      this.pageScrollInstance.scrollTarget.substr(0, 1) === '#'\n    ) {\n      // \"Navigate\" to the current route again and this time set the fragment/hash\n      this.router.navigate([], {\n        fragment: <string>this.pageScrollInstance.scrollTarget.substr(1),\n        queryParamsHandling: 'preserve',\n      });\n    }\n  }\n\n  private scroll(): void {\n    const pageScrollInstance = this.generatePageScrollInstance();\n    this.pushRouterState();\n    this.pageScrollService.start(pageScrollInstance);\n  }\n\n  @HostListener('click')\n  public handleClick(): boolean {\n    if (this.routerLink && this.router !== null && this.router !== undefined) {\n      let urlTree: UrlTree;\n      if (typeof this.routerLink === 'string') {\n        urlTree = this.router.parseUrl(this.routerLink);\n      } else {\n        urlTree = this.router.createUrlTree(this.routerLink);\n      }\n      if (!this.router.isActive(urlTree, true)) {\n        // We need to navigate their first.\n        // Navigation is handled by the routerLink directive\n        // so we only need to listen for route change\n        const subscription: Subscription = <Subscription>this.router.events.subscribe(\n          routerEvent => {\n            if (routerEvent instanceof NavigationEnd) {\n              subscription.unsubscribe();\n              this.scroll();\n            } else if (\n              routerEvent instanceof NavigationError ||\n              routerEvent instanceof NavigationCancel\n            ) {\n              subscription.unsubscribe();\n            }\n          }\n        );\n        return false; // to preventDefault()\n      }\n    }\n    this.scroll();\n    return false; // to preventDefault()\n  }\n}\n"]}