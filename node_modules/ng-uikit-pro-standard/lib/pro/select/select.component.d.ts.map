{"version":3,"file":"select.component.d.ts","sources":["../../../../../projects/ng-uikit-pro-standard/src/lib/pro/select/select.component.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  Input,\n  ViewContainerRef,\n  ElementRef,\n  ViewChild,\n  TemplateRef,\n  Output,\n  EventEmitter,\n  ContentChildren,\n  QueryList,\n  AfterContentInit,\n  OnDestroy,\n  OnInit,\n  ChangeDetectorRef,\n  Self,\n  Optional,\n  HostListener,\n  Renderer2,\n  ContentChild,\n  HostBinding,\n} from '@angular/core';\nimport { dropdownAnimation } from './select-animations';\nimport { fromEvent, merge, Subject } from 'rxjs';\nimport { filter, takeUntil, startWith, switchMap, tap } from 'rxjs/operators';\nimport { MDB_OPTION_PARENT, OptionComponent } from '../option/option.component';\nimport { NgControl, ControlValueAccessor } from '@angular/forms';\nimport { OptionGroupComponent } from '../option/option-group.component';\nimport { SelectAllOptionComponent } from '../option/select-all-option';\nimport {\n  OverlayRef,\n  PositionStrategy,\n  Overlay,\n  ViewportRuler,\n  ConnectionPositionPair,\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport {\n  ESCAPE,\n  UP_ARROW,\n  HOME,\n  END,\n  ENTER,\n  SPACE,\n  DOWN_ARROW,\n} from '../../free/utils/keyboard-navigation';\nimport { MdbSelectFilterComponent } from './select-filter.component';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { SelectionModel } from '@angular/cdk/collections';\n\n@Component({\n  selector: 'mdb-select-2',\n  templateUrl: './select.component.html',\n  styleUrls: ['./select-module.scss'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  animations: [dropdownAnimation],\n  providers: [{ provide: MDB_OPTION_PARENT, useExisting: MdbSelectComponent }],\n})\n\n// tslint:disable-next-line:component-class-suffix\nexport class MdbSelectComponent\n  implements OnInit, OnDestroy, AfterContentInit, ControlValueAccessor {\n  @ViewChild('selectWrapper') private _selectWrapper: ElementRef;\n  @ViewChild('selectValue') private _selectValue: ElementRef;\n  @ViewChild('dropdownTemplate') _dropdownTemplate: TemplateRef<any>;\n  @ViewChild('dropdown') dropdown: ElementRef;\n  @ContentChild(MdbSelectFilterComponent) filter: MdbSelectFilterComponent;\n  @ViewChild('optionsWrapper') private _optionsWrapper: ElementRef;\n  @ViewChild('customContent') _customContent: ElementRef;\n  @ContentChild(SelectAllOptionComponent) selectAllOption: SelectAllOptionComponent;\n  @ContentChildren(OptionComponent, { descendants: true }) options: QueryList<OptionComponent>;\n  @ContentChildren(OptionGroupComponent) optionGroups: QueryList<OptionGroupComponent>;\n\n  @Input() allowClear = false;\n  @Input() clearButtonTabindex = 0;\n  @Input() disabled = false;\n  @Input() dropdownClass: string;\n  @Input() highlightFirst = true;\n  @Input() label = '';\n  @Input() multiple = false;\n  @Input() notFoundMsg = 'No results found';\n  @Input() outline = false;\n  @Input() placeholder: string;\n  @Input() tabindex = 0;\n  @Input() required = false;\n  @Input('aria-label') ariaLabel = '';\n  @Input('aria-labelledby') ariaLabelledby: string;\n  @Input()\n  get visibleOptions(): number {\n    return this._visibleOptions;\n  }\n\n  set visibleOptions(value: number) {\n    if (value !== 0) {\n      this._visibleOptions = value;\n      this.dropdownHeight = this.visibleOptions * this.optionHeight;\n    }\n  }\n  private _visibleOptions = 5;\n\n  @Input()\n  get optionHeight(): any {\n    return this._optionHeight;\n  }\n\n  set optionHeight(value: any) {\n    if (value !== 0) {\n      this._optionHeight = value;\n      this.dropdownHeight = this.visibleOptions * this.optionHeight;\n    }\n  }\n\n  private _optionHeight = 48;\n\n  @Input()\n  get dropdownHeight(): number {\n    return this._dropdownHeight;\n  }\n\n  set dropdownHeight(value: number) {\n    if (value !== 0) {\n      this._dropdownHeight = value;\n    }\n  }\n  protected _dropdownHeight = this.visibleOptions * this.optionHeight;\n\n  @Input()\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (newValue !== this._value) {\n      if (this.options) {\n        this._setSelection(newValue);\n      }\n\n      this._value = newValue;\n    }\n  }\n  private _value: any;\n\n  @Input()\n  get compareWith() {\n    return this._compareWith;\n  }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn === 'function') {\n      this._compareWith = fn;\n    }\n  }\n\n  @Input() sortComparator: (\n    a: OptionComponent,\n    b: OptionComponent,\n    options: OptionComponent[]\n  ) => number;\n\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n  @Output() opened: EventEmitter<any> = new EventEmitter<any>();\n  @Output() closed: EventEmitter<any> = new EventEmitter<any>();\n  @Output() selected: EventEmitter<OptionComponent> = new EventEmitter<OptionComponent>();\n  // tslint:disable-next-line:max-line-length\n  @Output() deselected: EventEmitter<OptionComponent | OptionComponent[]> = new EventEmitter<\n    OptionComponent | OptionComponent[]\n  >();\n  @Output() noOptionsFound: EventEmitter<string> = new EventEmitter<string>();\n\n  get activeOption(): OptionComponent | null {\n    if (this._keyManager) {\n      return this._keyManager.activeItem;\n    }\n\n    return null;\n  }\n\n  get selectionView(): string {\n    if (this.multiple) {\n      const selectedOptions = this._selectionModel.selected.map(option => option.label.trim());\n\n      return selectedOptions.join(', ');\n    }\n\n    if (this._selectionModel.selected[0]) {\n      return this._selectionModel.selected[0].label;\n    }\n\n    return '';\n  }\n\n  get hasSelection() {\n    return this._selectionModel && !this._selectionModel.isEmpty();\n  }\n\n  get allChecked() {\n    const selectionsNumber = this._selectionModel.selected.length;\n    const optionsNumber = this.options.length;\n\n    return selectionsNumber === optionsNumber;\n  }\n\n  private _keyManager: ActiveDescendantKeyManager<OptionComponent | null>;\n\n  private _overlayRef: OverlayRef | null;\n  private _portal: TemplatePortal;\n\n  private _selectionModel: SelectionModel<OptionComponent>;\n\n  previousSelectedValues: any;\n\n  private _destroy = new Subject<void>();\n\n  _isOpen = false;\n\n  _hasFocus = false;\n\n  _labelActive = false;\n\n  _showNoResultsMsg = false;\n\n  private _selectAllChecked = false;\n\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  @HostListener('keydown', ['$event'])\n  handleKeydown(event: any) {\n    if (!this.disabled) {\n      this._handleClosedKeydown(event);\n    }\n  }\n\n  @HostBinding('class.mdb-select')\n  get select() {\n    return true;\n  }\n\n  @HostBinding('class.mdb-select-outline')\n  get isOutline() {\n    return this.outline;\n  }\n\n  @HostBinding('attr.aria-multiselectable')\n  get isMultiselectable() {\n    return this.multiple;\n  }\n\n  @HostBinding('attr.aria-haspopup')\n  get hasPopup() {\n    return true;\n  }\n\n  @HostBinding('attr.aria-disabled')\n  get isDisabled() {\n    return this.disabled;\n  }\n\n  @HostBinding('attr.aria-expanded')\n  get isExpanded() {\n    return this._isOpen;\n  }\n\n  @HostBinding('attr.aria-role')\n  get role() {\n    return this.filter ? 'combobox' : 'listbox';\n  }\n\n  constructor(\n    private _overlay: Overlay,\n    private _viewportRuler: ViewportRuler,\n    private _vcr: ViewContainerRef,\n    private _cdRef: ChangeDetectorRef,\n    private _renderer: Renderer2,\n    @Self() @Optional() public ngControl: NgControl\n  ) {\n    if (this.ngControl) {\n      this.ngControl.valueAccessor = this;\n    }\n  }\n\n  ngAfterContentInit() {\n    this._initKeyManager();\n    this._setInitialValue();\n    this._listenToOptionClick();\n\n    if (this.selectAllOption) {\n      this._listenToSelectAllClick();\n    }\n\n    if (this.filter) {\n      this.filter.inputChange.pipe(takeUntil(this._destroy)).subscribe(() => {\n        if (this.multiple && !this.filter.value) {\n          this.previousSelectedValues = this.options\n            .filter(option => option.selected)\n            .map(option => option.value);\n        }\n      });\n    }\n  }\n\n  restoreMultipleOptions() {\n    if (this.multiple && this.filter) {\n      if (\n        this.filter.value &&\n        this.filter.value.length &&\n        this.previousSelectedValues &&\n        Array.isArray(this.previousSelectedValues)\n      ) {\n        if (!this.value || !Array.isArray(this.value)) {\n          this.value = [];\n        }\n        const optionValues = this.options.map(option => option.value);\n        this.previousSelectedValues.forEach(previousValue => {\n          if (\n            !this.value.some((v: any) => this.compareWith(v, previousValue)) &&\n            !optionValues.some(v => this.compareWith(v, previousValue))\n          ) {\n            // if a value that was selected before is deselected and not found in the options, it was deselected\n            // due to the filtering, so we restore it.\n            this.value.push(previousValue);\n          }\n        });\n      }\n\n      this.previousSelectedValues = this.value;\n    }\n  }\n\n  private _initKeyManager() {\n    const options = this.selectAllOption ? [this.selectAllOption, ...this.options] : this.options;\n\n    if (this.filter) {\n      this._keyManager = new ActiveDescendantKeyManager<OptionComponent | null>(\n        options\n      ).withVerticalOrientation();\n    } else {\n      this._keyManager = new ActiveDescendantKeyManager<OptionComponent | null>(options)\n        .withTypeAhead(200)\n        .withVerticalOrientation();\n    }\n  }\n\n  private _listenToOptionClick() {\n    this.options.changes\n      .pipe(\n        startWith(this.options),\n        tap(() => {\n          this._setInitialValue();\n          setTimeout(() => {\n            this._showNoResultsMsg = this.options.length === 0;\n            this._keyManager.setActiveItem(null);\n            this._initKeyManager();\n\n            if (this._isOpen) {\n              this._highlightFirstOption();\n\n              if (this._keyManager.activeItem) {\n                this._scrollToOption(this._keyManager.activeItem);\n              }\n            }\n          }, 0);\n        }),\n        switchMap((options: QueryList<OptionComponent>) => {\n          return merge(...options.map((option: OptionComponent) => option.click$));\n        }),\n        takeUntil(this._destroy)\n      )\n      .subscribe((clickedOption: OptionComponent) => this._handleOptionClick(clickedOption));\n  }\n\n  private _listenToSelectAllClick() {\n    this.selectAllOption.click$\n      .pipe(takeUntil(this._destroy))\n      .subscribe((option: SelectAllOptionComponent) => {\n        this.onSelectAll(option);\n      });\n  }\n\n  private _updateValue() {\n    let updatedValue: any = null;\n\n    if (this.multiple) {\n      updatedValue = this._selectionModel.selected.map(option => option.value);\n    } else {\n      updatedValue = this._selectionModel.selected[0].value;\n    }\n\n    this._value = updatedValue;\n    this.restoreMultipleOptions();\n    this._cdRef.markForCheck();\n  }\n\n  private _handleOptionClick(option: OptionComponent) {\n    if (option.disabled) {\n      return;\n    }\n\n    if (this.multiple) {\n      this._handleMultipleSelection(option);\n    } else {\n      this._handleSingleSelection(option);\n    }\n\n    this._updateLabeLPosition();\n    this._cdRef.markForCheck();\n  }\n\n  private _handleSingleSelection(option: OptionComponent) {\n    const currentSelection = this._selectionModel.selected[0];\n\n    this._selectionModel.select(option);\n    option.select();\n\n    if (currentSelection && currentSelection !== option) {\n      this._selectionModel.deselect(currentSelection);\n      currentSelection.deselect();\n      this.deselected.emit(currentSelection.value);\n    }\n\n    if (!currentSelection || (currentSelection && currentSelection !== option)) {\n      this._updateValue();\n      this.valueChange.emit(this.value);\n      this._onChange(this.value);\n      this.selected.emit(option.value);\n    }\n\n    this.close();\n    this._focus();\n    this._updateLabeLPosition();\n  }\n\n  private _handleMultipleSelection(option: OptionComponent) {\n    const currentSelections = this._selectionModel.selected;\n    if (option.selected) {\n      this._selectionModel.deselect(option);\n      option.deselect();\n      this.deselected.emit(currentSelections);\n    } else {\n      this._selectionModel.select(option);\n      option.select();\n      this.selected.emit(option.value);\n    }\n\n    this._selectAllChecked = this.allChecked ? true : false;\n\n    if (this.selectAllOption && !this._selectAllChecked) {\n      this.selectAllOption.deselect();\n    }\n\n    this._updateValue();\n    this._sortValues();\n    this.valueChange.emit(this.value);\n    this._onChange(this.value);\n    this._cdRef.markForCheck();\n  }\n\n  private _setSelection(selectValue: any | any[]) {\n    const previousSelected = this._selectionModel.selected;\n\n    previousSelected.forEach((selectedOption: OptionComponent) => {\n      selectedOption.deselect();\n    });\n    this._selectionModel.clear();\n\n    if (selectValue !== null) {\n      if (this.multiple) {\n        selectValue.forEach((value: any) => this._selectByValue(value));\n        this._sortValues();\n      } else {\n        this._selectByValue(selectValue);\n      }\n    }\n\n    this._updateLabeLPosition();\n    this._cdRef.markForCheck();\n  }\n\n  private _selectByValue(value: any) {\n    const matchingOption = this.options\n      .toArray()\n      .find(\n        (option: OptionComponent) => option.value != null && this._compareWith(option.value, value)\n      );\n\n    if (matchingOption) {\n      this._selectionModel.select(matchingOption);\n      matchingOption.select();\n      this.selected.emit(matchingOption.value);\n    }\n  }\n\n  private _setInitialValue() {\n    Promise.resolve().then(() => {\n      const value = this.ngControl ? this.ngControl.value : this._value;\n      this._setSelection(value);\n    });\n  }\n\n  onSelectAll(selectAlloption: SelectAllOptionComponent) {\n    if (!selectAlloption.selected && !this._selectAllChecked) {\n      this._selectAllChecked = true;\n      this.options.forEach((option: OptionComponent) => {\n        if (!option.disabled) {\n          this._selectionModel.select(option);\n          option.select();\n        }\n      });\n      this._updateValue();\n      this._sortValues();\n      this.valueChange.emit(this.value);\n      this._onChange(this.value);\n      this._updateLabeLPosition();\n      selectAlloption.select();\n    } else {\n      this._selectAllChecked = false;\n      this._selectionModel.clear();\n      this.options.forEach((option: OptionComponent) => {\n        option.deselect();\n      });\n      selectAlloption.deselect();\n      this._updateValue();\n      this.valueChange.emit(this.value);\n      this._onChange(this.value);\n      this._updateLabeLPosition();\n    }\n  }\n\n  open() {\n    if (this.disabled) {\n      return;\n    }\n\n    let overlayRef = this._overlayRef;\n\n    if (!overlayRef) {\n      this._portal = new TemplatePortal(this._dropdownTemplate, this._vcr);\n\n      overlayRef = this._overlay.create({\n        width: this._selectWrapper.nativeElement.offsetWidth,\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        positionStrategy: this._getOverlayPosition(),\n      });\n\n      this._overlayRef = overlayRef;\n\n      overlayRef.keydownEvents().subscribe((event: KeyboardEvent) => {\n        // tslint:disable-next-line: deprecation\n        const key = event.keyCode;\n\n        if (key === ESCAPE || (key === UP_ARROW && event.altKey)) {\n          event.preventDefault();\n          event.stopPropagation();\n          this.close();\n          this._focus();\n        }\n      });\n    }\n\n    if (overlayRef && !overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n      this._listenToOutSideCick(overlayRef, this._selectValue.nativeElement).subscribe(() =>\n        this.close()\n      );\n\n      if (this.filter) {\n        this.filter.focus();\n      }\n\n      this._highlightFirstOption();\n    }\n\n    if (this._viewportRuler) {\n      this._viewportRuler\n        .change()\n        .pipe(takeUntil(this._destroy))\n        .subscribe(() => {\n          if (this._isOpen && overlayRef) {\n            overlayRef.updateSize({ width: this._selectWrapper.nativeElement.offsetWidth });\n          }\n        });\n    }\n\n    setTimeout(() => {\n      const firstSelected = this._selectionModel.selected[0];\n      if (firstSelected) {\n        this._scrollToOption(firstSelected);\n      }\n    }, 0);\n\n    this.opened.emit();\n\n    setTimeout(() => {\n      this._renderer.listen(this.dropdown.nativeElement, 'keydown', (event: KeyboardEvent) => {\n        this._handleOpenKeydown(event);\n      });\n    }, 0);\n\n    this._updateLabeLPosition();\n\n    if (!this.filter) {\n      setTimeout(() => {\n        this.dropdown.nativeElement.focus();\n      }, 0);\n    }\n\n    this._isOpen = true;\n    this._cdRef.markForCheck();\n  }\n\n  private _sortValues() {\n    if (this.multiple) {\n      const options = this.options.toArray();\n\n      this._selectionModel.sort((a, b) => {\n        return this.sortComparator\n          ? this.sortComparator(a, b, options)\n          : options.indexOf(a) - options.indexOf(b);\n      });\n    }\n  }\n\n  private _listenToOutSideCick(overlayRef: OverlayRef, origin: HTMLElement) {\n    return fromEvent(document, 'click').pipe(\n      filter((event: MouseEvent) => {\n        const target = event.target as HTMLElement;\n        const notOrigin = target !== origin;\n        const notValue = !this._selectValue.nativeElement.contains(target);\n        const notOverlay = !!overlayRef && overlayRef.overlayElement.contains(target) === false;\n        return notOrigin && notValue && notOverlay;\n      }),\n      takeUntil(overlayRef.detachments())\n    );\n  }\n\n  private _getOverlayPosition(): PositionStrategy {\n    const positionStrategy = this._overlay\n      .position()\n      .flexibleConnectedTo(this._selectWrapper)\n      .withPositions(this._getPositions())\n      .withFlexibleDimensions(false);\n\n    return positionStrategy;\n  }\n\n  private _getPositions(): ConnectionPositionPair[] {\n    const bottomOffset = this.outline ? 4 : 6;\n    const topOffset = this.outline ? -7 : -3;\n    if (!this.outline) {\n      return [\n        {\n          originX: 'start',\n          originY: 'top',\n          offsetY: bottomOffset,\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'bottom',\n          offsetY: topOffset,\n          overlayX: 'start',\n          overlayY: 'bottom',\n        },\n      ];\n    } else {\n      return [\n        {\n          originX: 'start',\n          originY: 'bottom',\n          offsetY: bottomOffset,\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          offsetY: topOffset,\n          overlayX: 'start',\n          overlayY: 'bottom',\n        },\n      ];\n    }\n  }\n\n  close() {\n    if (!this._isOpen) {\n      return;\n    }\n\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n      this._isOpen = false;\n    }\n\n    this.closed.emit();\n    this._updateLabeLPosition();\n    this._keyManager.setActiveItem(null);\n    this._onTouched();\n    this._cdRef.markForCheck();\n  }\n\n  toggle() {\n    this._isOpen ? this.close() : this.open();\n  }\n\n  private _updateLabeLPosition() {\n    if (!this.placeholder && !this.hasSelected) {\n      this._labelActive = false;\n    } else {\n      this._labelActive = true;\n    }\n  }\n\n  get hasSelected() {\n    return this._selectionModel.selected.length !== 0;\n  }\n\n  private _scrollToOption(option: OptionComponent) {\n    let optionIndex: number;\n\n    if (this.multiple && this.selectAllOption) {\n      optionIndex = this.options.toArray().indexOf(option) + 1;\n    } else {\n      optionIndex = this.options.toArray().indexOf(option);\n    }\n\n    const groupsNumber = this._getNumberOfGroupsBeforeOption(optionIndex);\n\n    const scrollToIndex = optionIndex + groupsNumber;\n\n    const list = this._optionsWrapper.nativeElement;\n    const listHeight = list.offsetHeight;\n\n    if (optionIndex > -1) {\n      const optionTop = scrollToIndex * this.optionHeight;\n      const optionBottom = optionTop + this.optionHeight;\n\n      const viewTop = list.scrollTop;\n      const viewBottom = this.dropdownHeight;\n\n      if (optionBottom > viewBottom) {\n        list.scrollTop = optionBottom - listHeight;\n      } else if (optionTop < viewTop) {\n        list.scrollTop = optionTop;\n      }\n    }\n  }\n\n  private _getNumberOfGroupsBeforeOption(optionIndex: number): number {\n    if (this.optionGroups.length) {\n      const optionsList = this.options.toArray();\n      const groupsList = this.optionGroups.toArray();\n      const index = this.multiple ? optionIndex - 1 : optionIndex;\n      let groupsNumber = 0;\n\n      for (let i = 0; i <= index; i++) {\n        if (optionsList[i].group && optionsList[i].group === groupsList[groupsNumber]) {\n          groupsNumber++;\n        }\n      }\n\n      return groupsNumber;\n    }\n\n    return 0;\n  }\n\n  handleSelectionClear(event: MouseEvent) {\n    if (event.button === 2) {\n      return;\n    }\n\n    this._selectionModel.clear();\n    this.options.forEach((option: OptionComponent) => {\n      option.deselect();\n    });\n\n    if (this.selectAllOption && this._selectAllChecked) {\n      this.selectAllOption.deselect();\n      this._selectAllChecked = false;\n    }\n    this.value = null;\n    this.valueChange.emit(null);\n    this._onChange(null);\n    this._updateLabeLPosition();\n    this._selectAllChecked = false;\n  }\n\n  private _handleOpenKeydown(event: any) {\n    const key = event.keyCode;\n    const manager = this._keyManager;\n    const isUserTyping = manager.isTyping();\n    const previousActiveItem = manager.activeItem;\n    manager.onKeydown(event);\n\n    if (key === HOME || key === END) {\n      event.preventDefault();\n      key === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n      if (manager.activeItem) {\n        this._scrollToOption(manager.activeItem);\n      }\n    } else if (\n      this._overlayRef &&\n      this._overlayRef.hasAttached() &&\n      !isUserTyping &&\n      manager.activeItem &&\n      (key === ENTER || (key === SPACE && !this.filter))\n    ) {\n      event.preventDefault();\n\n      if (this.multiple && this.selectAllOption && manager.activeItemIndex === 0) {\n        this.onSelectAll(this.selectAllOption);\n      } else {\n        this._handleOptionClick(manager.activeItem);\n      }\n    } else if (key === UP_ARROW && event.altKey) {\n      event.preventDefault();\n      this.close();\n      this._focus();\n    } else if (key === UP_ARROW || key === DOWN_ARROW) {\n      if (manager.activeItem && manager.activeItem !== previousActiveItem) {\n        this._scrollToOption(manager.activeItem);\n      }\n    }\n  }\n\n  private _handleClosedKeydown(event: any) {\n    const key = event.keyCode;\n    const manager = this._keyManager;\n\n    if ((key === DOWN_ARROW && event.altKey) || key === ENTER) {\n      event.preventDefault();\n      this.open();\n    } else if (!this.multiple && key === DOWN_ARROW) {\n      event.preventDefault();\n      manager.setNextItemActive();\n      if (manager.activeItem) {\n        this._handleOptionClick(manager.activeItem);\n      }\n    } else if (!this.multiple && key === UP_ARROW) {\n      event.preventDefault();\n      manager.setPreviousItemActive();\n      if (manager.activeItem) {\n        this._handleOptionClick(manager.activeItem);\n      }\n    } else if (!this.multiple && key === HOME) {\n      event.preventDefault();\n      manager.setFirstItemActive();\n      if (manager.activeItem) {\n        this._handleOptionClick(manager.activeItem);\n      }\n    } else if (!this.multiple && key === END) {\n      event.preventDefault();\n      manager.setLastItemActive();\n      if (manager.activeItem) {\n        this._handleOptionClick(manager.activeItem);\n      }\n    } else if (this.multiple && (key === DOWN_ARROW || key === UP_ARROW)) {\n      event.preventDefault();\n      this.open();\n    }\n  }\n\n  handleOptionsWheel(event: any) {\n    const optionsList = this._optionsWrapper.nativeElement;\n    const atTop = optionsList.scrollTop === 0;\n    const atBottom = optionsList.offsetHeight + optionsList.scrollTop === optionsList.scrollHeight;\n\n    if (atTop && event.deltaY < 0) {\n      event.preventDefault();\n    } else if (atBottom && event.deltaY > 0) {\n      event.preventDefault();\n    }\n  }\n\n  private _focus() {\n    this._hasFocus = true;\n    this._selectWrapper.nativeElement.focus();\n  }\n\n  private _highlightFirstOption() {\n    if (!this.hasSelection) {\n      this._keyManager.setFirstItemActive();\n    } else if (this.hasSelection && !this._selectionModel.selected[0].disabled) {\n      this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n    }\n  }\n\n  onFocus() {\n    if (!this.disabled) {\n      this._focus();\n    }\n  }\n\n  onBlur() {\n    if (!this._isOpen && !this.disabled) {\n      this._onTouched();\n    }\n    this._hasFocus = false;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<OptionComponent>(this.multiple);\n\n    if (this.label) {\n      this._updateLabeLPosition();\n    }\n  }\n\n  ngOnDestroy() {\n    this._destroy.next();\n    this._destroy.complete();\n  }\n\n  /** ControlValueAccessor interface methods. **/\n\n  private _onChange = (_: any) => {};\n  private _onTouched = () => {};\n\n  writeValue(value: any) {\n    this.value = value;\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._cdRef.markForCheck();\n  }\n\n  registerOnChange(fn: (_: any) => void) {\n    this._onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void) {\n    this._onTouched = fn;\n  }\n}\n"]}