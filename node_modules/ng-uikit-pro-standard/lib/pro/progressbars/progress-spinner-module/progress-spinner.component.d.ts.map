{"version":3,"file":"progress-spinner.component.d.ts","sources":["../../../../../../projects/ng-uikit-pro-standard/src/lib/pro/progressbars/progress-spinner-module/progress-spinner.component.ts"],"names":[],"mappings":"AAAA,OAAO,EAIL,SAAS,EAET,UAAU,EACV,MAAM,EACN,SAAS,EAEV,MAAM,eAAe,CAAC;;AAiBvB,oBAAY,mBAAmB,GAAG,aAAa,GAAG,eAAe,CAAC;AASlE;AACA;AACA;AACA,GAAG;AACH,qBAGa,sCAAsC;AACnD,IAA6C,IAAI,EAAE,GAAG,CAAC;;;AACvD,CAAC;AAED;AACA;AACA,GAAG;AACH,qBAKa,0BAA2B,YAAW,SAAS;AAC5D,IA+FI,OAAO,CAAC,OAAO;AAAE,IACjB,OAAO,CAAC,WAAW;AAAE,IACrB,OAAO,CAAC,SAAS;AAAE,IAjGrB,8CAA8C;AAChD,IAAE,OAAO,CAAC,gBAAgB,CAAK;AAC/B,IACE,4CAA4C;AAC9C,IAAE,OAAO,CAAC,yBAAyB,CAAM;AACzC,IACE,2DAA2D;AAC7D,IAAE,OAAO,CAAC,KAAK,CAAiB;AAChC,IACE,OAAO,CAAC,KAAK,CAAsC;AACrD,IAAE,OAAO,CAAC,MAAM,CAAS;AACzB,IAAE,OAAO,CAAC,MAAM,CAAa;AAC7B,IACE,SAAS,EAAE,GAAG,CAAS;AACzB,IAAuB,UAAU,EAAE,MAAM,CAAC;AAC1C,IAAE;AACF;AACE;AACE;AAEJ,OADK;AACL,IAAE,IAAI,aAAa,WAEhB;AACH,IACE,IAAI,aAAa,WAEhB;AACH,IACE,oBAAoB;AACtB,IAAE,IAAI,wBAAwB,QAE3B;AACH,IAAE,oBAAoB;AACtB,IAAE,IAAI,wBAAwB,CAAC,QAAQ,KAAA,EAGpC;AACH,IACE;AACF;AACE,OAAG;AACL,IAAE,WAAW;AACR,IAGH,0EAA0E;AAC5E,IAAE,IACI,KAAK,IAAI,MAAM,CAElB;AACH,IAAE,IAAI,KAAK,CAAC,KAAK,EAAE,MAAM,EAEtB;AACH,IACE,4FAA4F;AAC9F,IAAE,IAEI,KAAK,IAAI,GAAG,CAKf;AACH,IAAE,IAAI,KAAK,CAAC,CAAC,EAAE,MAAM,GAAG,GAAG,EAMxB;AACH,IACE;AACF;AACE;AACE;AACE;AAEJ,OADG;AACL,IAAE,IAEI,IAAI,IAGO,mBAAmB,CADjC;AACH,IAAE,IAAI,IAAI,CAAC,IAAI,EAAE,mBAAmB,EAUjC;AACH,gBAEY,OAAO,EAAE,MAAM,EACf,WAAW,EAAE,UAAU,EACvB,SAAS,EAAE,SAAS,EACP,UAAU,CAAC,EAAE,MAAM,GAAG,GAAG;AAChD,IAIA;AACF;AACE;AACE;AACE;AACE;AACE;AACE;AACE;AAEJ,OADL;AACL,IAAE,OAAO,CAAC,cAAc;AACxB,IAgCE;AACF;AACE,OAAG;AACL,IAAE,OAAO,CAAC,4BAA4B;AAAE,IAwBtC;AACF;AACE,OAAG;AACL,IAAE,OAAO,CAAC,8BAA8B;AAAE,IAIxC;AACF;AACE;AACE,OAAC;AACL,IAAE,OAAO,CAAC,UAAU;AAAE,IAWpB;AACF;AACE;AACE,OAAC;AACL,IAAE,OAAO,CAAC,YAAY;AAAE,IAMtB,6DAA6D;AAC/D,IAAE,OAAO,CAAC,gBAAgB;;;AAAE,CAO3B;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qBAKa,kBAAmB,SAAQ,0BAA2B,YAAW,SAAS;AACvF,IAAoC,IAAI,EAAE,GAAG,CAAC;AAC9C,gBACc,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS;AAAG,IAK1E,WAAW;;;AACR,CAIJ;AACD","sourcesContent":["import {\n  Component,\n  HostBinding,\n  ChangeDetectionStrategy,\n  OnDestroy,\n  Input,\n  ElementRef,\n  NgZone,\n  Renderer2,\n  Directive,\n} from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { PLATFORM_ID, Inject } from '@angular/core';\n\n/** A single degree in radians. */\nconst DEGREE_IN_RADIANS = Math.PI / 180;\n/** Duration of the indeterminate animation. */\nconst DURATION_INDETERMINATE = 667;\n/** Duration of the indeterminate animation. */\nconst DURATION_DETERMINATE = 225;\n/** Start animation value of the indeterminate animation */\nconst startIndeterminate = 3;\n/** End animation value of the indeterminate animation */\nconst endIndeterminate = 80;\n/* Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden. */\nconst MAX_ANGLE = 359.99 / 100;\n\nexport type ProgressSpinnerMode = 'determinate' | 'indeterminate';\n\ntype EasingFn = (\n  currentTime: number,\n  startValue: number,\n  changeInValue: number,\n  duration: number\n) => number;\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * @docs-private\n */\n@Directive({\n  selector: '[mdbSpinners], mat-progress-spinner',\n})\nexport class MdProgressSpinnerCssMatStylerDirective {\n  @HostBinding('class.mat-progress-spinner') true: any;\n}\n\n/**\n * <md-progress-spinner> component.\n */\n@Component({\n  selector: 'mdb-Spinners, mat-progress-spinner',\n  templateUrl: 'progress-spinner.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MdProgressSpinnerComponent implements OnDestroy {\n  /** The id of the last requested animation. */\n  private _lastAnimationId = 0;\n\n  /** The id of the indeterminate interval. */\n  private _interdeterminateInterval: any;\n\n  /** The SVG <path> node that is used to draw the circle. */\n  private _path: SVGPathElement;\n\n  private _mode: ProgressSpinnerMode = 'determinate';\n  private _value: number;\n  private _color = 'primary';\n\n  isBrowser: any = false;\n  @Inject(PLATFORM_ID) platformId: string;\n  /**\n   * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this\n   * because voiceover does not report the progress indicator as indeterminate if the aria min\n   * and/or max value are number values.\n   */\n  get _ariaValueMin() {\n    return this.mode === 'determinate' ? 0 : null;\n  }\n\n  get _ariaValueMax() {\n    return this.mode === 'determinate' ? 100 : null;\n  }\n\n  /** @docs-private */\n  get interdeterminateInterval() {\n    return this._interdeterminateInterval;\n  }\n  /** @docs-private */\n  set interdeterminateInterval(interval) {\n    clearInterval(this._interdeterminateInterval);\n    this._interdeterminateInterval = interval;\n  }\n\n  /**\n   * Clean up any animations that were running.\n   */\n  ngOnDestroy() {\n    this._cleanupIndeterminateAnimation();\n  }\n\n  /** The color of the progress-spinner. Can be primary, accent, or warn. */\n  @Input()\n  get color(): string {\n    return this._color;\n  }\n  set color(value: string) {\n    this._updateColor(value);\n  }\n\n  /** Value of the progress circle. It is bound to the host as the attribute aria-valuenow. */\n  @Input()\n  @HostBinding('attr.aria-valuenow')\n  get value(): any {\n    if (this.mode === 'determinate') {\n      return this._value;\n    }\n    return;\n  }\n  set value(v: number | any) {\n    if (v != null && this.mode === 'determinate') {\n      const newValue = clamp(v);\n      this._animateCircle(this.value || 0, newValue);\n      this._value = newValue;\n    }\n  }\n\n  /**\n   * Mode of the progress circle\n   *\n   * Input must be one of the values from ProgressMode, defaults to 'determinate'.\n   * mode is bound to the host as the attribute host.\n   */\n  @HostBinding('attr.mode')\n  @Input()\n  get mode() {\n    return this._mode;\n  }\n  set mode(mode: ProgressSpinnerMode) {\n    if (mode !== this._mode) {\n      if (mode === 'indeterminate') {\n        this._startIndeterminateAnimation();\n      } else {\n        this._cleanupIndeterminateAnimation();\n        this._animateCircle(0, this._value);\n      }\n      this._mode = mode;\n    }\n  }\n\n  constructor(\n    private _ngZone: NgZone,\n    private _elementRef: ElementRef,\n    private _renderer: Renderer2,\n    @Inject(PLATFORM_ID) platformId?: string | any\n  ) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n\n  /**\n   * Animates the circle from one percentage value to another.\n   *\n   * @param animateFrom The percentage of the circle filled starting the animation.\n   * @param animateTo The percentage of the circle filled ending the animation.\n   * @param ease The easing function to manage the pace of change in the animation.\n   * @param duration The length of time to show the animation, in milliseconds.\n   * @param rotation The starting angle of the circle fill, with 0Â° represented at the top center\n   *    of the circle.\n   */\n  private _animateCircle(\n    animateFrom: number,\n    animateTo: number,\n    ease: EasingFn = linearEase,\n    duration = DURATION_DETERMINATE,\n    rotation = 0\n  ): void {\n    const id = ++this._lastAnimationId;\n    const startTime = Date.now();\n    const changeInValue = animateTo - animateFrom;\n\n    // No need to animate it if the values are the same\n    if (animateTo === animateFrom) {\n      this._renderArc(animateTo, rotation);\n    } else {\n      const animation = () => {\n        const elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));\n\n        this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);\n\n        // Prevent overlapping animations by checking if a new animation has been called for and\n        // if the animation has lasted longer than the animation duration.\n        if (id === this._lastAnimationId && elapsedTime < duration) {\n          requestAnimationFrame(animation);\n        }\n      };\n\n      // Run the animation outside of Angular's zone, in order to avoid\n      // hitting ZoneJS and change detection on each frame.\n      this._ngZone.runOutsideAngular(animation);\n    }\n  }\n\n  /**\n   * Starts the indeterminate animation interval, if it is not already running.\n   */\n  private _startIndeterminateAnimation(): void {\n    let rotationStartPoint = 0;\n    let start = startIndeterminate;\n    let end = endIndeterminate;\n    const duration = DURATION_INDETERMINATE;\n    const animate = () => {\n      this._animateCircle(start, end, materialEase, duration, rotationStartPoint);\n      // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.\n      rotationStartPoint = (rotationStartPoint + end) % 100;\n      const temp = start;\n      start = -end;\n      end = -temp;\n    };\n\n    if (this.isBrowser) {\n      if (!this.interdeterminateInterval) {\n        this._ngZone.runOutsideAngular(() => {\n          this.interdeterminateInterval = setInterval(animate, duration + 50, 0, false);\n          animate();\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes interval, ending the animation.\n   */\n  private _cleanupIndeterminateAnimation(): void {\n    this.interdeterminateInterval = null;\n  }\n\n  /**\n   * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper\n   * DOM attribute on the `<path>`.\n   */\n  private _renderArc(currentValue: number, rotation = 0): void {\n    // Caches the path reference so it doesn't have to be looked up every time.\n    const path = (this._path = this._path || this._elementRef.nativeElement.querySelector('path'));\n\n    // Ensure that the path was found. This may not be the case if the\n    // animation function fires too early.\n    if (path) {\n      path.setAttribute('d', getSvgArc(currentValue, rotation));\n    }\n  }\n\n  /**\n   * Updates the color of the progress-spinner by adding the new palette class to the element\n   * and removing the old one.\n   */\n  private _updateColor(newColor: string): void {\n    this._setElementColor(this._color, false);\n    this._setElementColor(newColor, true);\n    this._color = newColor;\n  }\n\n  /** Sets the given palette class on the component element. */\n  private _setElementColor(color: string, isAdd: boolean) {\n    if (color != null && color !== '') {\n      if (isAdd) {\n        this._renderer.addClass(this._elementRef.nativeElement, `mat-${color}`);\n      }\n    }\n  }\n}\n\n/**\n * <md-spinner> component.\n *\n * This is a component definition to be used as a convenience reference to create an\n * indeterminate <md-progress-spinner> instance.\n */\n@Component({\n  selector: 'mdb-spinners, mat-spinner, mdb-progress-spinner',\n  templateUrl: 'progress-spinner.component.html',\n  styleUrls: ['progress-spinner.component.scss'],\n})\nexport class MdSpinnerComponent extends MdProgressSpinnerComponent implements OnDestroy {\n  @HostBinding('class.mat-spinner') true: any;\n\n  constructor(elementRef: ElementRef, ngZone: NgZone, renderer: Renderer2) {\n    super(ngZone, elementRef, renderer);\n    this.mode = 'indeterminate';\n  }\n\n  ngOnDestroy() {\n    // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because\n    // in certain cases Angular won't call it (e.g. when using AoT and in unit tests).\n    super.ngOnDestroy();\n  }\n}\n\n/**\n * Module functions.\n */\n\n/** Clamps a value to be between 0 and 100. */\nfunction clamp(v: number) {\n  return Math.max(0, Math.min(100, v));\n}\n\n/**\n * Converts Polar coordinates to Cartesian.\n */\nfunction polarToCartesian(radius: number, pathRadius: number, angleInDegrees: number) {\n  const angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\n\n  return (\n    radius +\n    pathRadius * Math.cos(angleInRadians) +\n    ',' +\n    (radius + pathRadius * Math.sin(angleInRadians))\n  );\n}\n\n/**\n * Easing function for linear animation.\n */\nfunction linearEase(\n  currentTime: number,\n  startValue: number,\n  changeInValue: number,\n  duration: number\n) {\n  return (changeInValue * currentTime) / duration + startValue;\n}\n\n/**\n * Easing function to match material design indeterminate animation.\n */\nfunction materialEase(\n  currentTime: number,\n  startValue: number,\n  changeInValue: number,\n  duration: number\n) {\n  const time = currentTime / duration;\n  const timeCubed = Math.pow(time, 3);\n  const timeQuad = Math.pow(time, 4);\n  const timeQuint = Math.pow(time, 5);\n  return startValue + changeInValue * (6 * timeQuint + -15 * timeQuad + 10 * timeCubed);\n}\n\n/**\n * Determines the path value to define the arc.  Converting percentage values to to polar\n * coordinates on the circle, and then to cartesian coordinates in the viewport.\n *\n * @param currentValue The current percentage value of the progress circle, the percentage of the\n *    circle to fill.\n * @param rotation The starting point of the circle with 0 being the 0 degree point.\n * @return A string for an SVG path representing a circle filled from the starting point to the\n *    percentage value provided.\n */\nfunction getSvgArc(currentValue: number, rotation: number) {\n  const startPoint = rotation || 0;\n  const radius = 50;\n  const pathRadius = 40;\n\n  const startAngle = startPoint * MAX_ANGLE;\n  const endAngle = currentValue * MAX_ANGLE;\n  const start = polarToCartesian(radius, pathRadius, startAngle);\n  const end = polarToCartesian(radius, pathRadius, endAngle + startAngle);\n  const arcSweep = endAngle < 0 ? 0 : 1;\n  let largeArcFlag: number;\n\n  if (endAngle < 0) {\n    largeArcFlag = endAngle >= -180 ? 0 : 1;\n  } else {\n    largeArcFlag = endAngle <= 180 ? 0 : 1;\n  }\n\n  return `M${start}A${pathRadius},${pathRadius} 0 ${largeArcFlag},${arcSweep} ${end}`;\n}\n"]}