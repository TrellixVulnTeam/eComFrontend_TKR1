{"version":3,"file":"mdb-multi-range.component.d.ts","sources":["../../../../../../projects/ng-uikit-pro-standard/src/lib/pro/range/multi-range/mdb-multi-range.component.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,UAAU,EACV,YAAY,EAIZ,SAAS,EAGT,MAAM,EACN,aAAa,EAEd,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,oBAAoB,EAAqB,MAAM,gBAAgB,CAAC;;AAEzE,eAAO,MAAM,mBAAmB,EAAE,GAKjC,CAAC;AAEF,qBAQa,2BAA4B,YAAW,MAAM,EAAE,aAAa,EAAE,oBAAoB;AAC/F,IAyBc,OAAO,CAAC,QAAQ;AAAE,IAzBrB,EAAE,EAAE,MAAM,CAAC;AACtB,IAAW,QAAQ,EAAE,OAAO,CAAC;AAC7B,IAAW,IAAI,EAAE,MAAM,CAAC;AACxB,IAAW,KAAK,EAAE;AAAE,QAAA,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC;AAAC,QAAA,MAAM,EAAE,MAAM,GAAG,MAAM,CAAA;AAAC,KAAC,CAA2B;AAChG,IAAW,QAAQ,EAAE,OAAO,CAAC;AAC7B,IAAW,GAAG,SAAK;AACnB,IAAW,GAAG,SAAO;AACrB,IAAW,IAAI,EAAE,MAAM,CAAC;AACxB,IACY,gBAAgB;AAAiB,eAAY,MAAM;AAAE,gBAAQ,MAAM;AAAE,OAAI;AACrF,IAC6C,UAAU,EAAE,UAAU,CAAC;AACpE,IAA8C,WAAW,EAAE,UAAU,CAAC;AACtE,IAAkD,eAAe,EAAE,UAAU,CAAC;AAC9E,IAAmD,gBAAgB,EAAE,UAAU,CAAC;AAChF,IAA6C,UAAU,EAAE,UAAU,CAAC;AACpE,IACE,KAAK,EAAE,GAAG,CAAC;AACb,IACE,KAAK,EAAE,MAAM,CAAC;AAChB,IAAE,UAAU,EAAE,MAAM,CAAC;AACrB,IAAE,eAAe,UAAS;AAC1B,IAAE,gBAAgB,UAAS;AAC3B,IAAE,UAAU,SAAK;AACjB,gBACsB,QAAQ,EAAE,SAAS;AAAG,IAE1C,QAAQ;AACL,IAGH,eAAe;AACZ,IAUH,eAAe,CAAC,KAAK,EAAE,GAAG;AACxB,IAUF,gBAAgB,CAAC,KAAK,EAAE,GAAG;AACzB,IAUF,OAAO,CAAC,cAAc;AAAE,IA+BxB,eAAe,CAAC,OAAO,EAAE,MAAM;AAC5B,IAQH,cAAc,CAAC,OAAO,EAAE,MAAM;AAC3B,IAQH,aAAa;AACP,IAaN,QAAQ,MAAO,GAAG,UAAQ;AAC5B,IAAE,SAAS,aAAY;AACvB,IACE,UAAU,CAAC,KAAK,EAAE,GAAG,GAAG,IAAI;AAAE,IAc9B,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,GAAG,IAAI;AAAE,IAI9C,iBAAiB,CAAC,EAAE,EAAE,MAAM,IAAI,GAAG,IAAI;AAAE,IAIzC,gBAAgB,CAAC,UAAU,EAAE,OAAO;;;AACjC,CAEJ;AACD","sourcesContent":["import {\n  Component,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Input,\n  Output,\n  Renderer2,\n  ViewChild,\n  ViewEncapsulation,\n  OnInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nexport const RANGE_VALUE_ACCESOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line: no-use-before-declare\n  useExisting: forwardRef(() => MdbMultiRangeInputComponent),\n  multi: true,\n};\n\n@Component({\n  selector: 'mdb-multi-range-input',\n  templateUrl: 'mdb-multi-range.component.html',\n  styleUrls: ['./../range-module.scss'],\n  encapsulation: ViewEncapsulation.None,\n  providers: [RANGE_VALUE_ACCESOR],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MdbMultiRangeInputComponent implements OnInit, AfterViewInit, ControlValueAccessor {\n  @Input() id: string;\n  @Input() required: boolean;\n  @Input() name: string;\n  @Input() value: { first: number | string; second: number | string } = { first: 0, second: 0 };\n  @Input() disabled: boolean;\n  @Input() min = 0;\n  @Input() max = 100;\n  @Input() step: number;\n\n  @Output() rangeValueChange = new EventEmitter<{ first: number; second: number }>();\n\n  @ViewChild('firstInput', { static: true }) firstInput: ElementRef;\n  @ViewChild('secondInput', { static: true }) secondInput: ElementRef;\n  @ViewChild('firstRangeCloud', { static: true }) firstRangeCloud: ElementRef;\n  @ViewChild('secondRangeCloud', { static: true }) secondRangeCloud: ElementRef;\n  @ViewChild('rangeField', { static: true }) rangeField: ElementRef;\n\n  range: any;\n\n  steps: number;\n  stepLength: number;\n  firstVisibility = false;\n  secondVisibility = false;\n  cloudRange = 0;\n\n  constructor(private renderer: Renderer2) {}\n\n  ngOnInit() {\n    this.range = this.value;\n  }\n\n  ngAfterViewInit() {\n    this.steps = this.max - this.min;\n\n    // fix(slider): resolve problem with not moving slider cloud when setting value with [value] or reactive forms\n    // Manual call the moveValueCloud method to move range value cloud to proper position based on the `value` variable\n    if (this.value) {\n      this.moveValueCloud(new Event('input'), 'first', Number(this.value.first));\n      this.moveValueCloud(new Event('input'), 'second', Number(this.value.second));\n    }\n  }\n\n  firstRangeInput(event: any) {\n    this.rangeValueChange.emit(this.range);\n\n    if (typeof this.range === 'object' && this.range.first === 0) {\n      return this.range;\n    }\n\n    this.focusRangeInput('first');\n    this.moveValueCloud(event, 'first');\n  }\n\n  secondRangeInput(event: any) {\n    this.rangeValueChange.emit(this.range);\n\n    if (typeof this.range === 'object' && this.range.second === 0) {\n      return this.range;\n    }\n\n    this.focusRangeInput('second');\n    this.moveValueCloud(event, 'second');\n  }\n\n  private moveValueCloud(event: any, element: string, value?: number) {\n    // if `moveValueCloud()` is called by (input) event take value as event.target.value.\n    // If it's called manually, take value from parameter.\n\n    // This is needed in situation, when slider value is set by default or ReactiveForms,\n    // and value clound is not moved to proper position\n    const newValue = event.target ? event.target.value : value;\n    const newRelativeGain = newValue - this.min;\n    const inputWidth =\n      element === 'first'\n        ? this.firstInput.nativeElement.offsetWidth\n        : this.secondInput.nativeElement.offsetWidth;\n\n    let thumbOffset = 0;\n    const offsetAmmount = 15;\n    const distanceFromMiddle = newRelativeGain - this.steps / 2;\n\n    this.stepLength = inputWidth / this.steps;\n\n    thumbOffset = (distanceFromMiddle / this.steps) * offsetAmmount;\n    this.cloudRange = this.stepLength * newRelativeGain - thumbOffset;\n\n    this.renderer.setStyle(\n      element === 'first'\n        ? this.firstRangeCloud.nativeElement\n        : this.secondRangeCloud.nativeElement,\n      'left',\n      this.cloudRange + 'px'\n    );\n  }\n\n  focusRangeInput(element: string) {\n    if (this.checkIfSafari()) {\n      element === 'first'\n        ? this.firstInput.nativeElement.focus()\n        : this.secondInput.nativeElement.focus();\n    }\n    element === 'first' ? (this.firstVisibility = true) : (this.secondVisibility = true);\n  }\n\n  blurRangeInput(element: string) {\n    if (this.checkIfSafari()) {\n      element === 'first'\n        ? this.firstInput.nativeElement.blur()\n        : this.secondInput.nativeElement.blur();\n    }\n    element === 'first' ? (this.firstVisibility = false) : (this.secondVisibility = false);\n  }\n\n  checkIfSafari() {\n    const isSafari = navigator.userAgent.indexOf('Safari') > -1;\n    const isChrome = navigator.userAgent.indexOf('Chrome') > -1;\n    const isFirefox = navigator.userAgent.indexOf('Firefox') > -1;\n    const isOpera = navigator.userAgent.indexOf('Opera') > -1;\n\n    if (isSafari && !isChrome && !isFirefox && !isOpera) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // Control Value Accessor Methods\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  writeValue(value: any): void {\n    this.value = value;\n    this.range = value;\n\n    // fix(slider): resolve problem with not moving slider cloud when setting value with [value] or reactive forms\n    // Manual call the moveValueCloud method to move range value cloud to proper position based on the `value` variable\n    if (value) {\n      setTimeout(() => {\n        this.moveValueCloud(new Event('input'), 'first', Number(value.first));\n        this.moveValueCloud(new Event('input'), 'second', Number(value.second));\n      }, 0);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n  }\n}\n"]}