{"version":3,"file":"mdb-auto-completer.directive.d.ts","sources":["../../../../../../projects/ng-uikit-pro-standard/src/lib/pro/auto-completer/directives/mdb-auto-completer.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EAEb,UAAU,EACV,YAAY,EAGZ,SAAS,EAET,SAAS,EAIV,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,yBAAyB,EAAE,MAAM,4CAA4C,CAAC;AAKvF,OAAO,EAAE,oBAAoB,EAAqB,MAAM,gBAAgB,CAAC;;AAMzE,eAAO,MAAM,+BAA+B,EAAE,GAK7C,CAAC;AAEF,qBAYa,yBAA0B,YAAW,aAAa,EAAE,SAAS,EAAE,oBAAoB;AAChG,IAwEI,OAAO,CAAC,QAAQ;AAAE,IAClB,OAAO,CAAC,EAAE;AAAE,IAEM,OAAO,CAAC,QAAQ;AAAE,IA3E7B,gBAAgB,EAAE,yBAAyB,CAAC;AACvD,IAAY,aAAa,oBAA2B;AACpD,IAAY,eAAe,oBAA2B;AACtD,IACE,OAAO,CAAC,SAAS,CAAgC;AACnD,IACE,OAAO,CAAC,0BAA0B,CAAmB;AACvD,IAAE,OAAO,CAAC,YAAY,CAAM;AAC5B,IAAE,OAAO,CAAC,eAAe,CAAQ;AACjC,IAAE,OAAO,CAAC,KAAK,CAAsB;AACrC,IAAE,OAAO,CAAC,SAAS,CAAS;AAC5B,IACE,kBAAkB,EAAE,QAAQ,CAAC;AAC/B,IAAE,UAAU,EAAE,QAAQ,GAAG,IAAI,CAAC;AAC9B,IAAE,SAAS,EAAE,OAAO,CAAC;AACrB,IACE,IACI,UAAU,IAAI,OAAO,CAExB;AACH,IAEE,SAAS,CAAC,KAAK,EAAE,GAAG;AACjB,IAQH,YAAY,CAAC,KAAK,EAAE,GAAG;AACpB,IAaH,cAAc;AACX,IAcH,aAAa;AACV,IAMH,eAAe;AACZ,gBAIO,QAAQ,EAAE,SAAS,EACnB,EAAE,EAAE,UAAU,EACD,UAAU,EAAE,MAAM,EACb,QAAQ,EAAE,GAAG;AACzC,IAIA,OAAO,CAAC,kBAAkB;AAAE,IA2B5B,OAAO,CAAC,4BAA4B;AAAE,IAStC,OAAO,CAAC,UAAU;AAAE,IAOpB,OAAO,CAAC,SAAS;AAAE,IAMnB,OAAO,CAAC,WAAW;AAAE,IAOd,KAAK;AACT,IAGI,cAAc,CAAC,KAAK,EAAE,GAAG;AAC7B,IAQH,SAAS,CAAC,IAAI,EAAE,GAAG,GAAG,GAAG;AAAE,IAmB3B,OAAO,CAAC,OAAO;AAAE,IAIjB,OAAO,CAAC,KAAK;AAAE,IAiBf,OAAO,CAAC,KAAK;AAAE,IAIf,OAAO,CAAC,sBAAsB;AAAE,IAmBhC,eAAe;AACZ,IA2FH,WAAW;AACR,IAeH,SAAS,EAAE,CAAC,KAAK,EAAE,GAAG,KAAK,IAAI,CAAY;AAC7C,IACE,UAAU,aAAY;AACxB,IACE,UAAU,CAAC,KAAK,EAAE,GAAG,GAAG,IAAI;AAAE,IAY9B,gBAAgB,CAAC,UAAU,EAAE,OAAO;AACjC,IAGH,gBAAgB,CAAC,EAAE,EAAE,CAAC,KAAK,EAAE,GAAG,KAAK,EAAE,GAAG,IAAI;AAAE,IAIhD,iBAAiB,CAAC,EAAE,EAAE,MAAM,EAAE;;;AAC3B,CAEJ;AACD","sourcesContent":["import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  OnDestroy,\n  Output,\n  Renderer2,\n  forwardRef,\n  HostListener,\n  HostBinding,\n} from '@angular/core';\nimport { MdbAutoCompleterComponent } from '../components/mdb-auto-completer.component';\nimport { ISelectedOption } from '../interfaces/selected-option.interface';\n\nimport { PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Utils } from '../../../free/utils';\nimport { TAB, ESCAPE, ENTER } from '../../../free/utils/keyboard-navigation';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line: no-use-before-declare\n  useExisting: forwardRef(() => MdbAutoCompleterDirective),\n  multi: true,\n};\n\n@Directive({\n  selector: 'input[mdbAutoCompleter], textarea[mdbAutoCompleter]',\n  // tslint:disable-next-line:no-host-metadata-property\n  host: {\n    '(input)': '_handleInput($event)',\n    '(focusin)': '_handleFocusIn()',\n    '(blur)': '_handleBlurIn()',\n    '(mousedown)': '_handleMouseDown()',\n  },\n  exportAs: 'mdbAutoCompleterTrigger',\n  providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n})\nexport class MdbAutoCompleterDirective implements AfterViewInit, OnDestroy, ControlValueAccessor {\n  @Input() mdbAutoCompleter: MdbAutoCompleterComponent;\n  @Output() ngModelChange = new EventEmitter<any>();\n  @Output() clearBtnClicked = new EventEmitter<any>();\n\n  private _destroy$: Subject<void> = new Subject();\n\n  private _autocompleterInputChanges: MutationObserver;\n  private _clearButton: any;\n  private _canOpenOnFocus = true;\n  private utils: Utils = new Utils();\n  private _disabled = false;\n\n  listenToClearClick: Function;\n  listenFunc: Function | null;\n  isBrowser: boolean;\n\n  @HostBinding('class.disabled')\n  get isDisabled(): boolean {\n    return this._disabled;\n  }\n\n  @HostListener('keydown', ['$event'])\n  onKeydown(event: any) {\n    this._handleKeyDown(event);\n    const isTabKey = event.keyCode === TAB;\n    if (isTabKey) {\n      this._hide();\n    }\n  }\n\n  @HostListener('input', ['$event'])\n  _handleInput(event: any) {\n    if (!this._isOpen()) {\n      this._show();\n    }\n\n    this._onChange(event.target.value);\n\n    this.mdbAutoCompleter.removeHighlight(0);\n    this.mdbAutoCompleter.highlightRow(0);\n\n    this._updateClearButtonVisibility();\n  }\n\n  @HostListener('focusin')\n  _handleFocusIn() {\n    if (!this._canOpenOnFocus) {\n      this._canOpenOnFocus = true;\n    } else {\n      this._show();\n    }\n  }\n\n  /*\nfix(completer): Resolve problem with closing autocompleter dropdown\nwhen not neccessary (eg. clicking on button which is not an mdb-option.\nWithout calling this _hide() method, autocompleter dropdown won't close\nafter switching focus programmatically to another element.\n*/\n  @HostListener('blur')\n  _handleBlurIn() {\n    this._canOpenOnFocus = this.document.activeElement !== this.el.nativeElement;\n\n    this._onTouched();\n  }\n\n  @HostListener('mousedown')\n  handleMouseDown() {\n    this.mdbAutoCompleter.highlightRow(0);\n  }\n\n  constructor(\n    private renderer: Renderer2,\n    private el: ElementRef,\n    @Inject(PLATFORM_ID) platformId: string,\n    @Inject(DOCUMENT) private document: any\n  ) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n\n  private _renderClearButton() {\n    const el = this.renderer.createElement('button');\n\n    this._setStyles(el, {\n      visibility: 'hidden',\n    });\n\n    this._addClass(el, ['mdb-autocomplete-clear']);\n\n    this.renderer.setAttribute(el, 'type', 'button');\n    this.renderer.setAttribute(\n      el,\n      'tabindex',\n      this.mdbAutoCompleter.clearButtonTabIndex.toString()\n    );\n    this.listenToClearClick = this.renderer.listen(el, 'click', () => {\n      this.clearBtnClicked.emit();\n      this._onChange('');\n    });\n\n    if (this.isBrowser) {\n      const parent =\n        this.utils.getClosestEl(this.el.nativeElement, '.md-form') || this.el.nativeElement;\n      this.renderer.appendChild(parent, el);\n    }\n  }\n\n  private _updateClearButtonVisibility() {\n    const clearButtonVisibility = this.el.nativeElement.value.length > 0 ? 'visible' : 'hidden';\n    if (this.mdbAutoCompleter.clearButton) {\n      const clearButton = this.el.nativeElement.parentElement.lastElementChild;\n\n      this._setStyles(clearButton, { visibility: clearButtonVisibility });\n    }\n  }\n\n  private _setStyles(target: ElementRef, styles: any) {\n    Object.keys(styles).forEach((prop: any) => {\n      this.renderer.setStyle(target, prop, styles[prop]);\n    });\n    return this;\n  }\n\n  private _addClass(target: ElementRef, name: string[]) {\n    name.forEach((el: string) => {\n      this.renderer.addClass(target, el);\n    });\n  }\n\n  private _clearInput() {\n    this.el.nativeElement.value = '';\n    this.ngModelChange.emit('');\n    const clearButton = this.el.nativeElement.parentElement.lastElementChild;\n    this._setStyles(clearButton, { visibility: 'hidden' });\n  }\n\n  public clear() {\n    this._clearInput();\n  }\n\n  public _handleKeyDown(event: any) {\n    this.mdbAutoCompleter.navigateUsingKeyboard(event);\n    const key = event.keyCode;\n\n    if (key !== ESCAPE && key !== ENTER && key !== TAB) {\n      this.mdbAutoCompleter.show();\n    }\n  }\n\n  getCoords(elem: any): any {\n    if (this.isBrowser) {\n      const box: ClientRect = elem.getBoundingClientRect();\n      const body: any = document.body;\n      const docEl: any = document.documentElement;\n\n      const scrollTop: number = window.pageYOffset || docEl.scrollTop || body.scrollTop;\n      const scrollLeft: number = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n\n      const clientTop: number = docEl.clientTop || body.clientTop || 0;\n      const clientLeft: number = docEl.clientLeft || body.clientLeft || 0;\n\n      const top: number = box.top + scrollTop - clientTop;\n      const left: number = box.left + scrollLeft - clientLeft;\n\n      return { top: Math.round(top), left: Math.round(left) };\n    }\n  }\n\n  private _isOpen() {\n    return this.mdbAutoCompleter.isOpen();\n  }\n\n  private _show() {\n    if (this._disabled) {\n      return;\n    }\n\n    this.mdbAutoCompleter.show();\n    setTimeout(() => {\n      if (this.mdbAutoCompleter.appendToBody) {\n        if (this.utils.getClosestEl(this.el.nativeElement, '.modal-body')) {\n          setTimeout(() => {\n            this.renderer.setStyle(this.mdbAutoCompleter.dropdown.nativeElement, 'z-index', '1100');\n          }, 0);\n        }\n      }\n    }, 0);\n  }\n\n  private _hide() {\n    this.mdbAutoCompleter.hide();\n  }\n\n  private _appendDropdownToInput() {\n    const position: ClientRect = this.el.nativeElement.getBoundingClientRect();\n    const el = this.el.nativeElement;\n    const style = window.getComputedStyle(this.el.nativeElement);\n    const height = ['height', 'padding-top', 'padding-bottom', 'margin-top', 'margin-bottom']\n      .map(key => parseInt(style.getPropertyValue(key), 10))\n      .reduce((prev, cur) => prev + cur);\n\n    this.mdbAutoCompleter.parameters = {\n      left: this.getCoords(el).left,\n      top: this.getCoords(el).top + height,\n      width: position.width,\n      bottom: window.innerHeight - height - el.getBoundingClientRect().top,\n      inputHeight: this.el.nativeElement.offsetHeight,\n    };\n\n    this.mdbAutoCompleter.appendDropdown();\n  }\n\n  ngAfterViewInit() {\n    this.mdbAutoCompleter\n      .selectedItemChanged()\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((item: ISelectedOption) => {\n        const displayedValue =\n          this.mdbAutoCompleter && this.mdbAutoCompleter.displayValue\n            ? this.mdbAutoCompleter.displayValue(item.text)\n            : item.text;\n\n        this.el.nativeElement.value = displayedValue;\n        this._onChange(item.text);\n        const clearButtonVisibility = this.el.nativeElement.value.length > 0 ? 'visible' : 'hidden';\n        const clearButton = this.el.nativeElement.parentElement.lastElementChild;\n        this._setStyles(clearButton, { visibility: clearButtonVisibility });\n\n        if (item) {\n          this._canOpenOnFocus = false;\n          this.el.nativeElement.focus();\n          this._hide();\n        }\n      });\n\n    this.mdbAutoCompleter.origin = this.el;\n\n    this.mdbAutoCompleter._isDropdownOpen\n      .pipe(takeUntil(this._destroy$))\n      .subscribe((state: boolean) => {\n        if (state) {\n          this._appendDropdownToInput();\n\n          if (!this.listenFunc) {\n            this.listenFunc = this.renderer.listen('document', 'click', event => {\n              if (\n                this.mdbAutoCompleter.dropdown &&\n                !this.mdbAutoCompleter.dropdown.nativeElement.contains(\n                  event.target as HTMLElement\n                ) &&\n                !this.el.nativeElement.contains(event.target as HTMLElement)\n              ) {\n                this._hide();\n              }\n            });\n          }\n        } else {\n          if (this.listenFunc) {\n            this.listenFunc();\n            this.listenFunc = null;\n          }\n        }\n      });\n\n    if (this.mdbAutoCompleter.clearButton && this.isBrowser) {\n      this._renderClearButton();\n      const clearButton = this.el.nativeElement.parentElement.querySelectorAll(\n        '.mdb-autocomplete-clear'\n      )[0];\n\n      this._clearButton = this.document.querySelector('.mdb-autocomplete-clear');\n\n      this.renderer.listen(clearButton, 'focus', () => {\n        ['click', 'keydown:space', 'keydown:enter'].forEach(event =>\n          this.renderer.listen(clearButton, event, () => {\n            this._clearInput();\n          })\n        );\n      });\n\n      this.renderer.listen(clearButton, 'click', () => {\n        this._clearInput();\n      });\n\n      if (this.el.nativeElement.disabled) {\n        this.renderer.setAttribute(clearButton, 'disabled', 'true');\n      }\n\n      this._autocompleterInputChanges = new MutationObserver((mutations: MutationRecord[]) => {\n        mutations.forEach((mutation: MutationRecord) => {\n          if (mutation.attributeName === 'disabled') {\n            this.renderer.setAttribute(this._clearButton, 'disabled', 'true');\n          }\n        });\n      });\n\n      this._autocompleterInputChanges.observe(this.el.nativeElement, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    if (this._autocompleterInputChanges) {\n      this._autocompleterInputChanges.disconnect();\n    }\n\n    if (this.listenToClearClick) {\n      this.listenToClearClick();\n    }\n    if (this.listenFunc) {\n      this.listenFunc();\n    }\n\n    this._destroy$.next();\n    this._destroy$.complete();\n  }\n\n  _onChange: (value: any) => void = () => {};\n\n  _onTouched = () => {};\n\n  writeValue(value: any): void {\n    Promise.resolve(null).then(() => {\n      const displayedValue =\n        this.mdbAutoCompleter && this.mdbAutoCompleter.displayValue\n          ? this.mdbAutoCompleter.displayValue(value)\n          : value;\n\n      this.el.nativeElement.value = displayedValue;\n      this._updateClearButtonVisibility();\n    });\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    this._disabled = isDisabled;\n  }\n\n  registerOnChange(fn: (value: any) => {}): void {\n    this._onChange = fn;\n  }\n\n  registerOnTouched(fn: () => {}) {\n    this._onTouched = fn;\n  }\n}\n"]}