{"version":3,"file":"sticky-header.directive.d.ts","sources":["../../../../../projects/ng-uikit-pro-standard/src/lib/free/sticky-header/sticky-header.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EAEb,UAAU,EACV,YAAY,EAGZ,SAAS,EACT,SAAS,EACV,MAAM,eAAe,CAAC;;AAmBvB,qBAIa,qBAAsB,YAAW,aAAa,EAAE,SAAS;AACtE,IAQc,OAAO,CAAC,SAAS;AAAE,IAAW,OAAO,CAAC,GAAG;AAAE,IAR9C,iBAAiB,SAAO;AACnC,IAAY,aAAa,EAAE,YAAY,CAAC;AAAE,QAAA,KAAK,EAAE,MAAM,CAAA;AAAC,KAAC,CAAC,CAAyC;AACnG,IACE,OAAO,CAAC,SAAS,CAAgC;AACnD,IACE,OAAO,CAAC,WAAW,CAAM;AAC3B,IAAE,OAAO,CAAC,SAAS,CAAM;AACzB,gBACsB,SAAS,EAAE,SAAS,EAAU,GAAG,EAAE,UAAU;AAAG,IAEpE,eAAe;AACZ,IAiDH,WAAW;;;AACR,CAGJ;AACD","sourcesContent":["import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  Output,\n  Renderer2,\n  OnDestroy,\n} from '@angular/core';\nimport { fromEvent, Subject } from 'rxjs';\nimport { window } from '../utils/facade/browser';\nimport {\n  distinctUntilChanged,\n  filter,\n  map,\n  pairwise,\n  share,\n  skip,\n  throttleTime,\n  takeUntil,\n} from 'rxjs/operators';\n\nenum Direction {\n  Up = 'Up',\n  Down = 'Down',\n}\n\n@Directive({\n  selector: '[mdbStickyHeader]',\n  exportAs: 'mdbStickyHeader',\n})\nexport class StickyHeaderDirective implements AfterViewInit, OnDestroy {\n  @Input() animationDuration = 200;\n  @Output() transitionEnd: EventEmitter<{ state: string }> = new EventEmitter<{ state: string }>();\n\n  private _destroy$: Subject<void> = new Subject();\n\n  private scrollDown$: any;\n  private scrollUp$: any;\n\n  constructor(private _renderer: Renderer2, private _el: ElementRef) {}\n\n  ngAfterViewInit() {\n    const scroll$ = fromEvent(window, 'scroll').pipe(\n      throttleTime(10),\n      map(() => window.pageYOffset),\n      pairwise(),\n      map(([y1, y2]): Direction => (y2 < y1 ? Direction.Up : Direction.Down)),\n      distinctUntilChanged(),\n      share()\n    );\n\n    this.scrollUp$ = scroll$.pipe(filter(direction => direction === Direction.Up));\n    this.scrollDown$ = scroll$.pipe(filter(direction => direction === Direction.Down));\n\n    this._renderer.setStyle(this._el.nativeElement, 'position', 'fixed');\n    this._renderer.setStyle(this._el.nativeElement, 'top', '0');\n    this._renderer.setStyle(this._el.nativeElement, 'width', '100%');\n    this._renderer.setStyle(this._el.nativeElement, 'z-index', '1030');\n\n    setTimeout(() => {\n      this.scrollUp$\n        .pipe(\n          skip(0),\n          takeUntil(this._destroy$)\n        )\n        .subscribe(() => {\n          this._renderer.setStyle(\n            this._el.nativeElement,\n            'transition',\n            `all ${this.animationDuration}ms ease-in`\n          );\n          this._renderer.setStyle(this._el.nativeElement, 'transform', 'translateY(0%)');\n          this.transitionEnd.emit({ state: 'Visible' });\n        });\n      this.scrollDown$\n        .pipe(\n          skip(0),\n          takeUntil(this._destroy$)\n        )\n        .subscribe(() => {\n          this._renderer.setStyle(\n            this._el.nativeElement,\n            'transition',\n            `all ${this.animationDuration}ms ease-in`\n          );\n          this._renderer.setStyle(this._el.nativeElement, 'transform', 'translateY(-100%)');\n          this.transitionEnd.emit({ state: 'Hidden' });\n        });\n    }, 0);\n  }\n\n  ngOnDestroy() {\n    this._destroy$.next();\n    this._destroy$.complete();\n  }\n}\n"]}