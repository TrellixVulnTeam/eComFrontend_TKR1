{"version":3,"file":"modal.directive.d.ts","sources":["../../../../../projects/ng-uikit-pro-standard/src/lib/free/modals/modal.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EAEb,YAAY,EACZ,UAAU,EACV,YAAY,EAGZ,SAAS,EACT,SAAS,EAET,SAAS,EACT,gBAAgB,EAEjB,MAAM,eAAe,CAAC;AAKvB,OAAO,EAAE,KAAK,EAAE,MAAM,sBAAsB,CAAC;AAC7C,OAAO,EAAE,sBAAsB,EAAE,MAAM,2BAA2B,CAAC;AACnE,OAAO,EAAmD,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAEhG,OAAO,EAAE,sBAAsB,EAAE,MAAM,oDAAoD,CAAC;AAC5F,OAAO,EAAa,4BAA4B,EAAE,MAAM,mBAAmB,CAAC;AAK5E,iEAAiE;;AACjE,qBASa,cAAe,YAAW,aAAa,EAAE,SAAS,EAAE,SAAS;AAC1E,IAsFI,SAAS,CAAC,QAAQ,EAAE,UAAU;AAClC,IAAI,OAAO,CAAC,iBAAiB;AAAE,IAE3B,SAAS,CAAC,SAAS,EAAE,SAAS;AAClC,IA1FE,6DAA6D;AAC/D,IAAE,IACW,MAAM,CAAC,IAAI,EAAE,YAAY,GAAG,GAAG,EAEzC;AACH,IACE,IAAW,MAAM,IAAI,YAAY,GAAG,GAAG,CAEtC;AACH,IACE,8EAA8E;AAChF,IACmB,MAAM,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC7F,IAAmB,IAAI,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC3F,IAAE,uHAAuH;AACzH,IACmB,OAAO,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC9F,IAAmB,MAAM,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC7F,IAAE,qFAAqF;AACvF,IACmB,MAAM,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC7F,IAAmB,KAAK,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC5F,IAAE,8HAA8H;AAChI,IACmB,QAAQ,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC/F,IAAmB,MAAM,EAAE,YAAY,CAAC,cAAc,CAAC,CAAsC;AAC7F,IAES,UAAU,UAAQ;AAC3B,IAAE;AACF,8GAA4G;AAC5G,IAAS,aAAa,EAAE,MAAM,GAAG,GAAG,CAAC;AACrC,IACE,IAAW,OAAO,IAAI,OAAO,CAE5B;AACH,IACE,SAAS,CAAC,OAAO,EAAE,YAAY,GAAG,GAAG,CAAC;AACxC,IAAE,SAAS,CAAC,QAAQ,UAAS;AAC7B,IACE,SAAS,CAAC,iBAAiB,UAAS;AACtC,IAAE,SAAS,CAAC,mBAAmB,SAAK;AACpC,IAAE,SAAS,CAAC,cAAc,SAAK;AAC/B,IACE,SAAS,CAAC,cAAc,EAAE,GAAG,CAAK;AACpC,IAAE,SAAS,CAAC,eAAe,EAAE,GAAG,CAAK;AACrC,IAEE,SAAS,CAAC,QAAQ,EAAE,YAAY,CAAC,sBAAsB,CAAC,GAAG,SAAS,CAAC;AACvE,IAAE,OAAO,CAAC,SAAS,CAA0C;AAC7D,IACE,OAAO,CAAC,UAAU,CAAY;AAChC,IACE,OAAO,EAAE,GAAG,CAAC;AACf,IACE,QAAQ,UAAS;AACnB,IACE,KAAK,EAAE,KAAK,CAAe;AAC7B,IAMS,OAAO,CAAC,KAAK,EAAE,GAAG,GAAG,IAAI;AAAE,IAc3B,KAAK,IAAI,IAAI;AAAE,gBAQV,QAAQ,EAAE,UAAU,EACtB,iBAAiB,EAAE,4BAA4B,EACvD,iBAAiB,EAAE,gBAAgB,EACzB,SAAS,EAAE,SAAS,EAC9B,GAAG,EAAE,sBAAsB;AAC7B,IAQO,WAAW,IAAI,GAAG;AAAE,IASpB,eAAe,IAAI,GAAG;AAAE,IAWxB,WAAW,IAAI,GAAG;AAAE,IAM3B,iDAAiD;AACnD,IAAS,MAAM,IAAI,IAAI;AAAE,IAIvB,oCAAoC;AACtC,IAAS,IAAI,IAAI,IAAI;AAAE,IAuCrB,qCAAqC;AACvC,IAAS,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,IAAI;AAAE,IAyClC,gCAAgC;AAClC,IAAE,SAAS,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,YAAY,GAAG,YAAY;AAAE,IAI1D;AACF;AACE;AACE,OAAC;AACL,IAAE,SAAS,CAAC,WAAW,IAAI,IAAI;AAAE,IAuC/B,OAAO,CAAC,gBAAgB;AAAE,IAM1B,gBAAgB;AAClB,IAAE,SAAS,CAAC,SAAS,IAAI,IAAI;AAAE,IAgB7B,gBAAgB;AAClB,IAAE,SAAS,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,QAAQ,GAAG,IAAI;AAAE,IA2CnD,gBAAgB;AAClB,IAAE,SAAS,CAAC,cAAc,IAAI,IAAI;AAAE,IAKlC,SAAS,CAAC,eAAe;AACtB,IAWH,gBAAgB;AAClB,IAAE,SAAS,CAAC,gBAAgB,IAAI,IAAI;AAAE,IAKpC,wBAAwB;AAC1B,IAAE,gBAAgB;AAClB,IAAE,SAAS,CAAC,cAAc,IAAI,IAAI;AAAE,IAKlC,SAAS,CAAC,YAAY,IAAI,IAAI;AAAE,IAWhC,SAAS,CAAC,iBAAiB,IAAI,MAAM;;;AAAE,CAQxC;AACD","sourcesContent":["import {\n  AfterViewInit,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  OnDestroy,\n  OnChanges,\n  Output,\n  Renderer2,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\n\nimport { document, navigator, window } from '../utils/facade/browser';\n\nimport { isBs3 } from '../utils/ng2-bootstrap-config';\nimport { Utils } from '../utils/utils.class';\nimport { ModalBackdropComponent } from './modalBackdrop.component';\nimport { ClassName, DISMISS_REASONS, modalConfigDefaults, ModalOptions } from './modal.options';\nimport { ComponentLoader } from '../utils/component-loader/component-loader.class';\nimport { ComponentLoaderFactory } from '../utils/component-loader/component-loader.factory';\nimport { FocusTrap, ConfigurableFocusTrapFactory } from '@angular/cdk/a11y';\n\nconst TRANSITION_DURATION = 300;\nconst BACKDROP_TRANSITION_DURATION = 150;\n\n/** Mark any code with directive to show it's content in modal */\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: '[mdbModal]',\n  template: '<ng-content></ng-content>',\n  styleUrls: ['./modals-module.scss'],\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'mdb-modal, mdbModal',\n})\n// tslint:disable-next-line:component-class-suffix\nexport class ModalDirective implements AfterViewInit, OnDestroy, OnChanges {\n  /** allows to set modal configuration via element property */\n  @Input()\n  public set config(conf: ModalOptions | any) {\n    this._config = this.getConfig(conf);\n  }\n\n  public get config(): ModalOptions | any {\n    return this._config;\n  }\n\n  /** This event fires immediately when the `show` instance method is called. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() public onShow: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  @Output() public open: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  /** This event is fired when the modal has been made visible to the user (will wait for CSS transitions to complete) */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() public onShown: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  @Output() public opened: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  /** This event is fired immediately when the hide instance method has been called. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() public onHide: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  @Output() public close: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  /** This event is fired when the modal has finished being hidden from the user (will wait for CSS transitions to complete). */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() public onHidden: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n  @Output() public closed: EventEmitter<ModalDirective> = new EventEmitter<ModalDirective>();\n\n  // seems like an Options\n  public isAnimated = true;\n  /** This field contains last dismiss reason.\n   Possible values: `backdrop-click`, `esc` and `null` (if modal was closed by direct call of `.hide()`). */\n  public dismissReason: string | any;\n\n  public get isShown(): boolean {\n    return this._isShown;\n  }\n\n  protected _config: ModalOptions | any;\n  protected _isShown = false;\n\n  protected isBodyOverflowing = false;\n  protected originalBodyPadding = 0;\n  protected scrollbarWidth = 0;\n\n  protected timerHideModal: any = 0;\n  protected timerRmBackDrop: any = 0;\n\n  // reference to backdrop component\n  protected backdrop: ComponentRef<ModalBackdropComponent> | undefined;\n  private _backdrop: ComponentLoader<ModalBackdropComponent>;\n\n  private _focusTrap: FocusTrap;\n  // todo: implement _dialog\n  _dialog: any;\n\n  isNested = false;\n\n  utils: Utils = new Utils();\n\n  /*   @HostListener('keydown', ['$event']) onKeyDown(event: any) {\n    this.utils.focusTrapModal(event, this._element);\n  }\n */\n  @HostListener('click', ['$event'])\n  public onClick(event: any): void {\n    if (\n      this.config.ignoreBackdropClick ||\n      this.config.backdrop === 'static' ||\n      event.target !== this._element.nativeElement\n    ) {\n      return;\n    }\n    this.dismissReason = DISMISS_REASONS.BACKRDOP;\n    this.hide(event);\n  }\n\n  // todo: consider preventing default and stopping propagation\n  @HostListener('keydown.esc')\n  public onEsc(): void {\n    if (this.config.keyboard) {\n      this.dismissReason = DISMISS_REASONS.ESC;\n      this.hide();\n    }\n  }\n\n  public constructor(\n    protected _element: ElementRef,\n    private _focusTrapFactory: ConfigurableFocusTrapFactory,\n    _viewContainerRef: ViewContainerRef,\n    protected _renderer: Renderer2,\n    clf: ComponentLoaderFactory\n  ) {\n    this._backdrop = clf.createLoader<ModalBackdropComponent>(\n      _element,\n      _viewContainerRef,\n      _renderer\n    );\n  }\n\n  public ngOnDestroy(): any {\n    this.config = void 0;\n    if (this._isShown) {\n      this._isShown = false;\n      this.hideModal();\n      this._backdrop.dispose();\n    }\n  }\n\n  public ngAfterViewInit(): any {\n    this._config = this._config || this.getConfig();\n    setTimeout(() => {\n      if (this._config.show) {\n        this.show();\n      }\n    }, 0);\n\n    this._createFocusTrap();\n  }\n\n  public ngOnChanges(): any {\n    this.config.backdrop ? this.showBackdrop() : this.removeBackdrop();\n  }\n\n  /* Public methods */\n\n  /** Allows to manually toggle modal visibility */\n  public toggle(): void {\n    return this._isShown ? this.hide() : this.show();\n  }\n\n  /** Allows to manually open modal */\n  public show(): void {\n    this.dismissReason = null;\n    this.onShow.emit(this);\n    this.open.emit(this);\n    if (this._isShown) {\n      return;\n    }\n    clearTimeout(this.timerHideModal);\n    clearTimeout(this.timerRmBackDrop);\n\n    this._isShown = true;\n\n    this.checkScrollbar();\n    this.setScrollbar();\n\n    if (document && document.body) {\n      if (document.body.classList.contains(ClassName.OPEN)) {\n        this.isNested = true;\n      } else {\n        this._renderer.addClass(document.body, ClassName.OPEN);\n      }\n    }\n    this.showBackdrop(() => {\n      this.showElement();\n    });\n    if (!this.config.backdrop && this.config.ignoreBackdropClick) {\n      this._renderer.setStyle(this._element.nativeElement, 'position', 'fixed');\n\n      if (\n        navigator.userAgent.indexOf('Safari') !== -1 &&\n        navigator.userAgent.indexOf('Chrome') === -1\n      ) {\n        this._renderer.setStyle(this._element.nativeElement, 'overflow', 'unset');\n        this._renderer.setStyle(this._element.nativeElement, 'overflow-y', 'unset');\n        this._renderer.setStyle(this._element.nativeElement, 'overflow-x', 'unset');\n      }\n    }\n  }\n\n  /** Allows to manually close modal */\n  public hide(event?: Event): void {\n    if (event) {\n      event.preventDefault();\n    }\n\n    // fix(modal): resolved problem with not pausing iframe/video when closing modal\n    const iframeElements = Array.from(this._element.nativeElement.querySelectorAll('iframe'));\n    const videoElements = Array.from(this._element.nativeElement.querySelectorAll('video'));\n\n    iframeElements.forEach((iframe: HTMLIFrameElement) => {\n      const srcAttribute: any = iframe.getAttribute('src');\n      this._renderer.setAttribute(iframe, 'src', srcAttribute);\n    });\n\n    videoElements.forEach((video: HTMLVideoElement) => {\n      video.pause();\n    });\n\n    this.onHide.emit(this);\n    this.close.emit(this);\n\n    if (!this._isShown) {\n      return;\n    }\n\n    clearTimeout(this.timerHideModal);\n    clearTimeout(this.timerRmBackDrop);\n\n    this._isShown = false;\n    this._renderer.removeClass(this._element.nativeElement, ClassName.IN);\n    if (!isBs3()) {\n      this._renderer.removeClass(this._element.nativeElement, ClassName.SHOW);\n    }\n\n    if (this.isAnimated) {\n      this.timerHideModal = setTimeout(() => this.hideModal(), TRANSITION_DURATION);\n    } else {\n      this.hideModal();\n    }\n  }\n\n  /** Private methods @internal */\n  protected getConfig(config?: ModalOptions): ModalOptions {\n    return Object.assign({}, modalConfigDefaults, config);\n  }\n\n  /**\n   *  Show dialog\n   *  @internal\n   */\n  protected showElement(): void {\n    if (\n      !this._element.nativeElement.parentNode ||\n      this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE\n    ) {\n      // don't move modals dom position\n      if (document && document.body) {\n        document.body.appendChild(this._element.nativeElement);\n      }\n    }\n\n    this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n    this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n    this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n\n    if (this.isAnimated) {\n      Utils.reflow(this._element.nativeElement);\n    }\n\n    this._renderer.addClass(this._element.nativeElement, ClassName.IN);\n    if (!isBs3()) {\n      this._renderer.addClass(this._element.nativeElement, ClassName.SHOW);\n    }\n\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._element.nativeElement.focus();\n      }\n      this.onShown.emit(this);\n      this.opened.emit(this);\n    };\n\n    if (this.isAnimated) {\n      setTimeout(transitionComplete, TRANSITION_DURATION);\n    } else {\n      transitionComplete();\n    }\n  }\n\n  private _createFocusTrap() {\n    if (!this._focusTrap) {\n      this._focusTrap = this._focusTrapFactory.create(this._element.nativeElement);\n    }\n  }\n\n  /** @internal */\n  protected hideModal(): void {\n    this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n    this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n    this.showBackdrop(() => {\n      if (!this.isNested) {\n        if (document && document.body) {\n          this._renderer.removeClass(document.body, ClassName.OPEN);\n        }\n      }\n      this.resetAdjustments();\n      this.focusOtherModal();\n      this.onHidden.emit(this);\n      this.closed.emit(this);\n    });\n  }\n\n  /** @internal */\n  protected showBackdrop(callback?: Function): void {\n    if (\n      this._isShown &&\n      this.config.backdrop &&\n      (!this.backdrop || !this.backdrop.instance.isShown)\n    ) {\n      this.removeBackdrop();\n      this._backdrop\n        .attach(ModalBackdropComponent)\n        .to('body')\n        .show({ isAnimated: this.isAnimated });\n      this.backdrop = this._backdrop._componentRef;\n\n      if (!callback) {\n        return;\n      }\n\n      if (!this.isAnimated) {\n        callback();\n        return;\n      }\n\n      setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n    } else if (!this._isShown && this.backdrop) {\n      this.backdrop.instance.isShown = false;\n\n      const callbackRemove = () => {\n        this.removeBackdrop();\n        if (callback) {\n          callback();\n        }\n      };\n\n      if (this.backdrop.instance.isAnimated) {\n        this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n      } else {\n        callbackRemove();\n      }\n    } else if (callback) {\n      callback();\n    }\n  }\n\n  /** @internal */\n  protected removeBackdrop(): void {\n    this._backdrop.hide();\n    this.backdrop = undefined;\n  }\n\n  protected focusOtherModal() {\n    try {\n      const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll(\n        '.in[mdbModal]'\n      );\n      if (!otherOpenedModals.length) {\n        return;\n      }\n      otherOpenedModals[otherOpenedModals.length - 1].nativeElement.focus();\n    } catch (error) {}\n  }\n\n  /** @internal */\n  protected resetAdjustments(): void {\n    this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n    this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n  }\n\n  /** Scroll bar tricks */\n  /** @internal */\n  protected checkScrollbar(): void {\n    this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n    this.scrollbarWidth = this.getScrollbarWidth();\n  }\n\n  protected setScrollbar(): void {\n    if (!document) {\n      return;\n    }\n    this.originalBodyPadding = parseInt(\n      window.getComputedStyle(document.body).getPropertyValue('padding-right') || 0,\n      10\n    );\n  }\n\n  // thx d.walsh\n  protected getScrollbarWidth(): number {\n    const scrollDiv = this._renderer.createElement('div', void 0);\n    this._renderer.appendChild(document.body, scrollDiv);\n    scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n    const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n  }\n}\n"]}