import { Component, ElementRef, Inject, Input, PLATFORM_ID, ViewEncapsulation, } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './progress-spinner-module/progress-spinner.component';
export class ProgressSpinnerComponent {
    constructor(el, platformId) {
        this.el = el;
        this.addClass = 'spinner-blue-only';
        this.isBrowser = false;
        this.spinnerType = '';
        this.spinnerColor = 'rainbow';
        this.isBrowser = isPlatformBrowser(platformId);
    }
    ngAfterViewInit() {
        const hostElem = this.el.nativeElement;
        const colorClass = this.spinnerColor;
        this.addClass = 'spinner-rainbow';
        switch (colorClass) {
            case 'green':
                this.addClass = 'spinner-green-only';
                break;
            case 'blue':
                this.addClass = 'spinner-blue-only';
                break;
            case 'yellow':
                this.addClass = 'spinner-yellow-only';
                break;
            case 'red':
                this.addClass = 'spinner-red-only';
                break;
            case 'rainbow':
                this.addClass = 'spinner-rainbow spinner-blue-only mat-progress-spinner';
                this.spinerRun();
                break;
        }
        hostElem.children[0].children[0].className += ' ' + this.addClass;
    }
    spinerRun() {
        let counter = 0;
        const hostElem = this.el.nativeElement;
        if (this.isBrowser) {
            setInterval(() => {
                switch (counter) {
                    case 0:
                        this.addClass = 'spinner-red-only mat-progress-spinner ';
                        break;
                    case 1:
                        this.addClass = 'spinner-yellow-only mat-progress-spinner';
                        break;
                    case 2:
                        this.addClass = 'spinner-blue-only mat-progress-spinner';
                        break;
                    case 3:
                        this.addClass = 'spinner-green-only mat-progress-spinner';
                        break;
                }
                hostElem.children[0].children[0].className = ' ' + this.addClass;
                if (counter < 3) {
                    counter++;
                }
                else {
                    counter = 0;
                }
            }, 1333);
        }
    }
}
ProgressSpinnerComponent.ɵfac = function ProgressSpinnerComponent_Factory(t) { return new (t || ProgressSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
ProgressSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ProgressSpinnerComponent, selectors: [["mdb-spinner"]], inputs: { spinnerType: "spinnerType", spinnerColor: "spinnerColor" }, decls: 2, vars: 3, consts: [["mdbSpinners", "", "mode", "indeterminate"]], template: function ProgressSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelement(1, "mdb-Spinners", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("preloader-wrapper active  ", ctx.spinnerType, "");
    } }, directives: [ɵngcc1.MdProgressSpinnerComponent, ɵngcc1.MdProgressSpinnerCssMatStylerDirective], styles: [""], encapsulation: 2 });
ProgressSpinnerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
ProgressSpinnerComponent.propDecorators = {
    spinnerType: [{ type: Input }],
    spinnerColor: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-spinner',
                template: "<div class=\"preloader-wrapper active  {{spinnerType}}\">\n    <mdb-Spinners mdbSpinners mode=\"indeterminate\"></mdb-Spinners>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { spinnerType: [{
            type: Input
        }], spinnerColor: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25nLXVpa2l0LXByby1zdGFuZGFyZC9zcmMvbGliL3Byby9wcm9ncmVzc2JhcnMvcHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxXQUFXLEVBQ1gsaUJBQWlCLEdBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFRcEQsTUFBTSxPQUFPLHdCQUF3QjtBQUFHLElBTXRDLFlBQW1CLEVBQWMsRUFBdUIsVUFBa0I7QUFDNUUsUUFEcUIsT0FBRSxHQUFGLEVBQUUsQ0FBWTtBQUFDLFFBTGxDLGFBQVEsR0FBVyxtQkFBbUIsQ0FBQztBQUN6QyxRQUFFLGNBQVMsR0FBRyxLQUFLLENBQUM7QUFDcEIsUUFBVyxnQkFBVyxHQUFHLEVBQUUsQ0FBQztBQUM1QixRQUFXLGlCQUFZLEdBQUcsU0FBUyxDQUFDO0FBQ3BDLFFBRUksSUFBSSxDQUFDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuRCxJQUFFLENBQUM7QUFDSCxJQUNFLGVBQWU7QUFDakIsUUFBSSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQztBQUMzQyxRQUFJLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDekMsUUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLGlCQUFpQixDQUFDO0FBQ3RDLFFBQ0ksUUFBUSxVQUFVLEVBQUU7QUFDeEIsWUFBTSxLQUFLLE9BQU87QUFDbEIsZ0JBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQztBQUM3QyxnQkFBUSxNQUFNO0FBQ2QsWUFBTSxLQUFLLE1BQU07QUFDakIsZ0JBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxtQkFBbUIsQ0FBQztBQUM1QyxnQkFBUSxNQUFNO0FBQ2QsWUFBTSxLQUFLLFFBQVE7QUFDbkIsZ0JBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxxQkFBcUIsQ0FBQztBQUM5QyxnQkFBUSxNQUFNO0FBQ2QsWUFBTSxLQUFLLEtBQUs7QUFDaEIsZ0JBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQztBQUMzQyxnQkFBUSxNQUFNO0FBQ2QsWUFBTSxLQUFLLFNBQVM7QUFDcEIsZ0JBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyx3REFBd0QsQ0FBQztBQUNqRixnQkFBUSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDekIsZ0JBQVEsTUFBTTtBQUNkLFNBQUs7QUFDTCxRQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUN0RSxJQUFFLENBQUM7QUFDSCxJQUNFLFNBQVM7QUFDWCxRQUFJLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNwQixRQUFJLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0FBQzNDLFFBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ3hCLFlBQU0sV0FBVyxDQUFDLEdBQUcsRUFBRTtBQUN2QixnQkFBUSxRQUFRLE9BQU8sRUFBRTtBQUN6QixvQkFBVSxLQUFLLENBQUM7QUFDaEIsd0JBQVksSUFBSSxDQUFDLFFBQVEsR0FBRyx3Q0FBd0MsQ0FBQztBQUNyRSx3QkFBWSxNQUFNO0FBQ2xCLG9CQUFVLEtBQUssQ0FBQztBQUNoQix3QkFBWSxJQUFJLENBQUMsUUFBUSxHQUFHLDBDQUEwQyxDQUFDO0FBQ3ZFLHdCQUFZLE1BQU07QUFDbEIsb0JBQVUsS0FBSyxDQUFDO0FBQ2hCLHdCQUFZLElBQUksQ0FBQyxRQUFRLEdBQUcsd0NBQXdDLENBQUM7QUFDckUsd0JBQVksTUFBTTtBQUNsQixvQkFBVSxLQUFLLENBQUM7QUFDaEIsd0JBQVksSUFBSSxDQUFDLFFBQVEsR0FBRyx5Q0FBeUMsQ0FBQztBQUN0RSx3QkFBWSxNQUFNO0FBQ2xCLGlCQUFTO0FBQ1QsZ0JBQ1EsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3pFLGdCQUFRLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRTtBQUN6QixvQkFBVSxPQUFPLEVBQUUsQ0FBQztBQUNwQixpQkFBUztBQUFDLHFCQUFLO0FBQ2Ysb0JBQVUsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUN0QixpQkFBUztBQUNULFlBQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2YsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNIO29EQXZFQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLGFBQWEsa0JBQ3ZCO2tFQUE4QyxrQkFFOUMsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUksNENBQ3RDOzs7Ozs7MklBQ0k7QUFBQztBQUFrRCxZQWR0RCxVQUFVO0FBQ1YseUNBbUJvQyxNQUFNLFNBQUMsV0FBVztBQUFRO0FBQUc7QUFDcEMsMEJBSjVCLEtBQUs7QUFBSywyQkFDVixLQUFLO0FBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgUExBVEZPUk1fSUQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWRiLXNwaW5uZXInLFxuICB0ZW1wbGF0ZVVybDogJ3Byb2dyZXNzLXNwaW5uZXIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9wcm9ncmVzc2JhcnMtbW9kdWxlLnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NTcGlubmVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGFkZENsYXNzOiBTdHJpbmcgPSAnc3Bpbm5lci1ibHVlLW9ubHknO1xuICBpc0Jyb3dzZXIgPSBmYWxzZTtcbiAgQElucHV0KCkgc3Bpbm5lclR5cGUgPSAnJztcbiAgQElucHV0KCkgc3Bpbm5lckNvbG9yID0gJ3JhaW5ib3cnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbDogRWxlbWVudFJlZiwgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogc3RyaW5nKSB7XG4gICAgdGhpcy5pc0Jyb3dzZXIgPSBpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBjb25zdCBob3N0RWxlbSA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBjb2xvckNsYXNzID0gdGhpcy5zcGlubmVyQ29sb3I7XG4gICAgdGhpcy5hZGRDbGFzcyA9ICdzcGlubmVyLXJhaW5ib3cnO1xuXG4gICAgc3dpdGNoIChjb2xvckNsYXNzKSB7XG4gICAgICBjYXNlICdncmVlbic6XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MgPSAnc3Bpbm5lci1ncmVlbi1vbmx5JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdibHVlJzpcbiAgICAgICAgdGhpcy5hZGRDbGFzcyA9ICdzcGlubmVyLWJsdWUtb25seSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneWVsbG93JzpcbiAgICAgICAgdGhpcy5hZGRDbGFzcyA9ICdzcGlubmVyLXllbGxvdy1vbmx5JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZWQnOlxuICAgICAgICB0aGlzLmFkZENsYXNzID0gJ3NwaW5uZXItcmVkLW9ubHknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JhaW5ib3cnOlxuICAgICAgICB0aGlzLmFkZENsYXNzID0gJ3NwaW5uZXItcmFpbmJvdyBzcGlubmVyLWJsdWUtb25seSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lcic7XG4gICAgICAgIHRoaXMuc3BpbmVyUnVuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBob3N0RWxlbS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jbGFzc05hbWUgKz0gJyAnICsgdGhpcy5hZGRDbGFzcztcbiAgfVxuXG4gIHNwaW5lclJ1bigpIHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgY29uc3QgaG9zdEVsZW0gPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuaXNCcm93c2VyKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY291bnRlcikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MgPSAnc3Bpbm5lci1yZWQtb25seSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lciAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyA9ICdzcGlubmVyLXllbGxvdy1vbmx5IG1hdC1wcm9ncmVzcy1zcGlubmVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MgPSAnc3Bpbm5lci1ibHVlLW9ubHkgbWF0LXByb2dyZXNzLXNwaW5uZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyA9ICdzcGlubmVyLWdyZWVuLW9ubHkgbWF0LXByb2dyZXNzLXNwaW5uZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBob3N0RWxlbS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jbGFzc05hbWUgPSAnICcgKyB0aGlzLmFkZENsYXNzO1xuICAgICAgICBpZiAoY291bnRlciA8IDMpIHtcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnRlciA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0sIDEzMzMpO1xuICAgIH1cbiAgfVxufVxuIl19