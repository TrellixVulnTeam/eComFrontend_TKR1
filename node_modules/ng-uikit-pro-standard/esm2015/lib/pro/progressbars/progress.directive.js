import { Directive, HostBinding, Input } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export class ProgressDirective {
    constructor() {
        this.addClass = true;
        this.bars = [];
        this._max = 100;
    }
    /** maximum total value of progress element */
    get max() {
        return this._max;
    }
    set max(v) {
        this._max = v;
        this.bars.forEach((bar) => {
            bar.recalculatePercentage();
        });
    }
    addBar(bar) {
        if (!this.animate) {
            bar.transition = 'none';
        }
        this.bars.push(bar);
    }
    removeBar(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    }
}
ProgressDirective.ɵfac = function ProgressDirective_Factory(t) { return new (t || ProgressDirective)(); };
ProgressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ProgressDirective, selectors: [["mdbProgress"], ["", "mdbProgress", ""]], hostVars: 3, hostBindings: function ProgressDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("max", ctx.max);
        ɵngcc0.ɵɵclassProp("progress", ctx.addClass);
    } }, inputs: { max: "max", animate: "animate" } });
ProgressDirective.propDecorators = {
    animate: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.max',] }, { type: Input }],
    addClass: [{ type: HostBinding, args: ['class.progress',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProgressDirective, [{
        type: Directive,
        args: [{ selector: 'mdbProgress, [mdbProgress]' }]
    }], function () { return []; }, { addClass: [{
            type: HostBinding,
            args: ['class.progress']
        }], max: [{
            type: HostBinding,
            args: ['attr.max']
        }, {
            type: Input
        }], animate: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MuZGlyZWN0aXZlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy11aWtpdC1wcm8tc3RhbmRhcmQvc3JjL2xpYi9wcm8vcHJvZ3Jlc3NiYXJzL3Byb2dyZXNzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBSzlELE1BQU0sT0FBTyxpQkFBaUI7QUFDOUIsSUFGQTtBQUFnQixRQW1Cd0IsYUFBUSxHQUFHLElBQUksQ0FBQztBQUN4RCxRQUNTLFNBQUksR0FBVSxFQUFFLENBQUM7QUFDMUIsUUFDWSxTQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ3ZCLElBV0EsQ0FBQztBQUNELElBL0JFLDhDQUE4QztBQUNoRCxJQUFFLElBRVcsR0FBRztBQUFLLFFBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztBQUNyQixJQUFFLENBQUM7QUFDSCxJQUNFLElBQVcsR0FBRyxDQUFDLENBQVM7QUFDMUIsUUFBSSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNsQixRQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBaUIsRUFBRSxFQUFFO0FBQzVDLFlBQU0sR0FBRyxDQUFDLHFCQUFxQixFQUFFLENBQUM7QUFDbEMsUUFBSSxDQUFDLENBQUMsQ0FBQztBQUNQLElBQUUsQ0FBQztBQUNILElBT1MsTUFBTSxDQUFDLEdBQWlCO0FBQUksUUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDdkIsWUFBTSxHQUFHLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztBQUM5QixTQUFLO0FBQ0wsUUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QixJQUFFLENBQUM7QUFDSCxJQUNTLFNBQVMsQ0FBQyxHQUFpQjtBQUFJLFFBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hELElBQUUsQ0FBQztBQUNIOzZDQW5DQyxTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsNEJBQTRCLEVBQUU7Ozs7dURBQ2hEO0FBQUM7QUFDSSxzQkFDUCxLQUFLO0FBQUssa0JBR1YsV0FBVyxTQUFDLFVBQVUsY0FDdEIsS0FBSztBQUNOLHVCQVdDLFdBQVcsU0FBQyxnQkFBZ0I7QUFBTTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEJhckNvbXBvbmVudCB9IGZyb20gJy4vYmFyLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ21kYlByb2dyZXNzLCBbbWRiUHJvZ3Jlc3NdJyB9KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzRGlyZWN0aXZlIHtcbiAgLyoqIGlmIGB0cnVlYCBjaGFuZ2luZyB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgd2lsbCBiZSBhbmltYXRlZCAobm90ZTogbm90IHN1cHBvcnRlZCBieSBCb290c3RyYXAgNCkgKi9cbiAgQElucHV0KCkgcHVibGljIGFuaW1hdGU6IGJvb2xlYW47XG5cbiAgLyoqIG1heGltdW0gdG90YWwgdmFsdWUgb2YgcHJvZ3Jlc3MgZWxlbWVudCAqL1xuICBASG9zdEJpbmRpbmcoJ2F0dHIubWF4JylcbiAgQElucHV0KClcbiAgcHVibGljIGdldCBtYXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4O1xuICB9XG5cbiAgcHVibGljIHNldCBtYXgodjogbnVtYmVyKSB7XG4gICAgdGhpcy5fbWF4ID0gdjtcbiAgICB0aGlzLmJhcnMuZm9yRWFjaCgoYmFyOiBCYXJDb21wb25lbnQpID0+IHtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3MucHJvZ3Jlc3MnKSBwdWJsaWMgYWRkQ2xhc3MgPSB0cnVlO1xuXG4gIHB1YmxpYyBiYXJzOiBhbnlbXSA9IFtdO1xuXG4gIHByb3RlY3RlZCBfbWF4ID0gMTAwO1xuXG4gIHB1YmxpYyBhZGRCYXIoYmFyOiBCYXJDb21wb25lbnQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0ZSkge1xuICAgICAgYmFyLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfVxuICAgIHRoaXMuYmFycy5wdXNoKGJhcik7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQmFyKGJhcjogQmFyQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy5iYXJzLnNwbGljZSh0aGlzLmJhcnMuaW5kZXhPZihiYXIpLCAxKTtcbiAgfVxufVxuIl19